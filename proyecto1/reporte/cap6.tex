\chapter{Puntos Estrictos}
Este es un capítulo corto pero escencial y crucial para la implementación de nuestro intéprete del lenguaje, ya que al meter recursión de la forma tradicional (como se explica en el capitulo 4 y 5), la manera en la que hemos planteado la evaluación hasta ahora necesita ser remodelada.\\

Para evitar el problema de las variables no definidas al utilizar recursion y combinadores, debemos volver a\minilisp perezo, es decir, debemos reeplantear la estrategia de evaluacion de\minilisp de glotón a perezoso.

Al usar evaluación perezosa, existen ciertos puntos dentro de la implementación en los que no puede
postergarse la evaluación.

\begin{quote}
  \textit{Explicar que es el alcance perezoso y lo que son puntos estrictos.}
\end{quote}

Para ello tenemos que definir un forma que nos permitia aplicar los \textit{puntos estrictos} de nuestro lenguaje. Este forma la modelaremos mediante una función \textbf{strict}, que reduce la expresión hasta llegar a un \textbf{valor canónico} del lenguaje.

\[
\textbf{strict}(\langle e, \varepsilon \rangle) =
\begin{cases}
e, & \text{si } e \text{ es valor},\\[4pt]
\langle e', \varepsilon \rangle, & \text{si } \langle e, \varepsilon \rangle \to \langle e', \varepsilon' \rangle.
\end{cases}
\]

Para aplicar este mecanismo, sí o sí necesitamos nuestras reglas semánticas de modo que apliquen los \textit{puntos estrictos} correspondientes usando \textbf{strict}. El resto de reglas se mantienen sin cambios, pero el cambio radica en que: aquellas expresiones donde detectamos la presencia de \textit{puntos estrictos} y recibian cerraduras de expresión ⟨e, $\varepsilon$⟩, es donde llamamos \textbf{strict}.

\section{Reglas semánticas perezosas con strict}

\begin{itemize}
\item AddV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle AddV(i,d), \varepsilon \rangle \to \langle AddV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle AddV(NumV(n),d), \varepsilon \rangle \to \langle Add(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle AddV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n +_{\Z} m), \varepsilon \rangle}
  \]
\item SubV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle SubV(i,d), \varepsilon \rangle \to \langle SubV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle SubV(NumV(n),d), \varepsilon \rangle \to \langle SubV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle SubV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n -_{\Z} m), \varepsilon \rangle}
  \]
\item MulV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle MulV(i,d), \varepsilon \rangle \to \langle MulV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle MulV(NumV(n),d), \varepsilon \rangle \to \langle MulV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle MulV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n *_{\Z} m), \varepsilon \rangle}
  \]
\item DiV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle DiV(i,d), \varepsilon \rangle \to \langle DiV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle DiV(NumV(n),d), \varepsilon \rangle \to \langle DiV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle DiV(NumV(n),NumV(0)), \varepsilon \to \text{Error en la ejecución de la evaluación}}
  \]
  \[
  \frac{}{ \langle DiV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n\ /_{\Z}\ m), \varepsilon \rangle} \quad (m \neq 0)
  \]
\item SqrtV(n):
\[
  \frac{\langle n, \varepsilon \rangle \to \langle n', \varepsilon \rangle}{\langle SqrtV(n), \varepsilon \rangle \to \langle SqrtV(n'), \varepsilon \rangle}
  \]
  \[
  \frac{n < 0}{\langle SqrtV(NumV(n)), \varepsilon \to \text{Error en la ejecución de la evaluación}}
  \]
  \[
  \frac{}{\langle SqrtV(NumV(n)), \varepsilon \rangle \to \langle NumV(\sqrt{n}_{\N}), \varepsilon \rangle}  \quad (n \geq 0)
  \]
\item NotV(b):
\[
  \frac{\langle b, \varepsilon \rangle \to \langle n', \varepsilon \rangle}{\langle NotV(b), \varepsilon \rangle \to \langle NotV(b'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle NotV(BoolV(b)), \varepsilon \rangle \to \langle BoolV(\neg_{\P}b) \varepsilon \rangle}
  \]
  
\item EqualV(i,d
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle EqualV(i,d), \varepsilon \rangle \to \langle EqualV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle EqualV(NumV(n),d), \varepsilon \rangle \to \langle EqualV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle EqualV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n =_{\Z} m), \varepsilon \rangle}
  \]
\item LessV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle LessV(i,d), \varepsilon \rangle \to \langle LessV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle LessV(NumV(n),d), \varepsilon \rangle \to \langle LessV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle LessV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n <_{\Z} m), \varepsilon \rangle}
  \]
\item GreaterV(i,d):
\item DiffV(i,d):
\item LeqV(i,d):
\item GeqV(i,d):
\item PairV(f,s):  
\item FstV(p):
\item SndV(p):
\item IfV(c,t,e):
\item ConV(i,d):
\item HeadV(l):
\item TailV(l);
\item FunV(p,c):
\item AppV(f,a):
\end{itemize}

\begin{quote}
  \textit{Consultar la pagina 13-14 del ultimo pdf del profesor para ver contexto}
\end{quote}

Una vez definido todo lo anterior, veamos su implementación en Haskell y cómo se modifica el interprete de\minilisp{-0.2cm}.

\section{Evaluación perezosa para \minilisp}

Como se mostró, al cambiar la estrategia de evaluación de nuestro intérprete, debemos hacer muchos cambios en su implementación en Haskell.

Con este nuevo enfoque, nuestro tipo de dato \texttt{ASV} ya es más reducido donde solo están los valores canónicos:

\begin{lstlisting}[style=haskellstyle, caption={Tipo de dato \texttt{ASV} con valores canónicos}]
module ASV where

import AST

{--
Definimos la representacion del ambiente de ejecucion.
Un ambiente es una lista de pares (id, valor).
--}
type Env = [(String, ASV)]

{-- ASA Values --}
data ASV
  = NumV Int
  | BoolV Bool
  | NiV
  | PairV ASV ASV
  | ConV ASV ASV
  | ClosureF String AST Env
  | ExprV AST Env
  deriving (Show, Eq)
\end{lstlisting}

%https://lambdasspace.github.io/LDP/notas/ldp_n06.pdf
%https://lambdasspace.github.io/LDP/notas/ldp_n07.pdf
%https://lambdasspace.github.io/LDP/notas/ldp_n12.pdf
%https://lambdasspace.github.io/LDP/notas/ldp_n13.pdf
%https://lambdasspace.github.io/LDP/notas/ldp_n14.pdf

A diferencia de la implementación anterior, en este nuevo interprete ya no tenemos que usar la función \texttt{toFinalState} para convertir los \textbf{ASA} en estados finales, ya que los únicos estados finales son los valores canónicos ({Ambas definiciones significan lo mismo pero recordemos que en la primer implementación hicimos el abuso de notación para marcar la diferencia entre ambos}, de eso se ecargará el nuevo intérprete, de convertir las expresion \texttt{AST} a estados finales (valores canónicos).\\

Definimos la función de evaluación perezosa con puntos estrictos como sigue:

\begin{lstlisting}[style=haskellstyle, caption={Evaluación perezosa con \textbf{strict} para\minilisp{-0.2cm}}]
module EvalStrict where

import AST
import ASV
import Interprete

{-- Funcion de evaluacion perezosa --}
evalS :: AST -> Env -> ASV
--Valores
evalS (VarC i) env = lookupS i env
evalS (NumC n) _   = (NumV n)
evalS (BoolC b) _  = (BoolV b)
evalS NiL _        = NiV
--Operadores aritmeticos
evalS (AddC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in NumV (numN i' + numN d')
evalS (SubC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in NumV (numN i' - numN d')
evalS (MulC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in NumV (numN i' * numN d')
evalS (DivC i d) env =
  let n = numN (strict (evalS i env))
      m = numN (strict (evalS d env))
   in if m == 0
        then error "No se puede dividir entre 0"
        else NumV (div n m)
evalS (SqrtC n) env =
  let n' = numN (strict (evalS n env))
   in if n' < 0
        then error "No se puede obtener la raiz de un numero negativo"
        else NumV (integerSquareRoot n')
--Not
evalS (NotC e) env =
  let e' = strict (evalS e env)
   in BoolV (not (boolN e'))
--Comparadores
evalS (EqualC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' == numN d')
evalS (LessC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' < numN d')
evalS (GreaterC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' > numN d')
evalS (DiffC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' /= numN d')
evalS (LeqC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' <= numN d')
evalS (GeqC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' >= numN d')
--Pares
evalS (PairC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in PairV i' d'
evalS (FstC p) env =
  case strict (evalS p env) of
    PairV f _ -> f
    _         -> error "Fst espera un par"
evalS (SndC p) env =
  case strict (evalS p env) of
    PairV _ s -> s
    _         -> error "Snd espera un par"
--Cons
evalS (ConS i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in ConV i' d'
evalS (HeadC p) env =
  case strict (evalS p env) of
    ConV h _ -> h
    _        -> error "Head espera una lista"
evalS (TailC p) env =
  case strict (evalS p env) of
    ConV _ t ->
      let t' = strict t
       in if not (isConV t')
          then t'
          else tailDeep t'
    _        -> error "Tail espera una lista"
--If
evalS (IfC c t e) env =
  let cond = boolN (strict (evalS c env))
   in if cond then evalS t env else evalS e env
--Funciones
evalS (FunC p c) env = ClosureF p c env
--Aplicacion de funciones
evalS (AppC f a) env =
  let f' = evalS f env
      funV = strict f'
   in evalS (closureC funV) (((closureP funV), ExprV a env) : (closureE funV))

{-- Funcion strict para forzar la evaluacion de los puntos estrictos --}
strict :: ASV -> ASV
strict (NumV n) = NumV n
strict (BoolV b) = BoolV b
strict (PairV f s) = PairV (strict f) (strict s)
strict (ConV i d) = ConV (strict i) (strict d)
strict (ExprV a e) = strict (evalS a e)
strict (NiV) = NiV
strict (ClosureF p c e) = ClosureF p c e

{-- Funcion auxiliar para devolver el numero de NumV--}
numN :: ASV -> Int
numN (NumV n) = n

{-- Funcion auxiliar para devolver el booleano de BoolV --}
boolN :: ASV -> Bool
boolN (BoolV b) = b
boolN _ = False

{-- Funcion auxiliar para devoler el parametro de la cerradura --}
closureP :: ASV -> String
closureP (ClosureF p _ _) = p

{-- Funcion auxiliar para devoler el cuerpo de la cerradura --}
closureC :: ASV -> AST
closureC (ClosureF _ c _) = c

{-- Funcion auxiliar para devoler el ambiente de la cerradura --}
closureE :: ASV -> Env
closureE (ClosureF _ _ e) = e

{-- Funcion auxiliar para encontrar el ultimo elemento canonico de los ConV anidados--}
tailDeep :: ASV -> ASV
tailDeep (ConV _ rest) =
  let rest' = strict rest
  in if not (isConV rest')
     then rest'
     else tailDeep rest'
tailDeep v = v

\end{lstlisting}

La mayor diferencia a \texttt{eval} es que la función \texttt{evalS} ya no utiliza la evaluación de paso pequeño, sino que implementa una evaluación directa (\textit{\textbf{big-step}}). Ahora utilizamos funciones auxiliares (\texttt{strict}, \texttt{numN}, \texttt{boolN}, etc.) para obtener valores “$forzados$”.

\noindent
Además de este cambio, lo más notorio es \texttt{TailC} y la aplicación de funciones. La primer expresión ahora utiliza una función auxiliar \texttt{tailDeep} para seguir buscando el último elemento en la anidación de \texttt{ConS}, ya que usar \texttt{evalS} nos da una inconsistencia de tipos, pues al evaluar por primera vez el par, este se transforma en un \texttt{ASV} siendo que \texttt{evalS} recibe \texttt{AST}.

\noindent
Para el caso de \texttt{AppC}:

\begin{enumerate}
\item Evalúa $f$ en el ambiente actual, esto debería devolver una cerradura.
\item Fuerza \textit{f'} con \texttt{strict}, asegurándose de que sea una cerradura concreta.
\item Extrae información de la cerradura:
  \begin{itemize}
  \item \texttt{closureC funV}: el cuerpo de la función.
  \item \texttt{closureP funV}: el nombre del parámetro formal.
  \item \texttt{closureE funV}: el ambiente donde la función fue creada.
\end{itemize}

\item Crea un nuevo ambiente donde:
  \begin{itemize}
  \item El parámetro formal (\texttt{closureP funV}) se asocia a la expresión real (\texttt{ExprV a env});
  \item Se añade al ambiente original de la cerradura (\texttt{closureE funV}).
  \end{itemize}
  
\item Evalúa el cuerpo de la función (\texttt{closureC funV}) en ese nuevo ambiente extendido.
\end{enumerate}

De este modo tenemos una evaluación adecuada para introducir recursión con \texttt{LetRec} en nuestro lenguaje\minilisp{-0.2cm}, pues como mencionamos, necesitamos meter al ambiente inicial la evaluación de nuestro combinador \textbf{Z}, el cuál se mostró que presentaba errores con la evaluación glotona.

\begin{quote}
  \textit{Aqui podemos poner un cierre del interprete, recursion y evaluacion glotona}
\end{quote}
