\chapter{Puntos Estrictos}
Este es un capítulo corto pero escencial y crucial para la implementación de nuestro intéprete del lenguaje, ya que al meter recursión de la forma tradicional (como se explica en el capitulo 4 y 5), la manera en la que hemos planteado la evaluación hasta ahora necesita ser remodelada.\\

Para evitar el problema de las variables no definidas al utilizar recursion y combinadores, debemos volver a\minilisp perezo, es decir, debemos reeplantear la estrategia de evaluacion de\minilisp de glotón a perezoso.

Al usar evaluación perezosa, existen ciertos puntos dentro de la implementación en los que no puede
postergarse la evaluación.

Para ello tenemos que definir un forma que nos permitia aplicar los \textit{puntos estrictos} de nuestro lenguaje. Este forma la modelaremos mediante una función \textbf{strict}, que reduce la expresión hasta llegar a un \textbf{valor canónico} del lenguaje.

\[
\textbf{strict}(\langle e, \varepsilon \rangle) =
\begin{cases}
e, & \text{si } e \text{ es valor},\\[4pt]
\langle e', \varepsilon \rangle, & \text{si } \langle e, \varepsilon \rangle \to \langle e', \varepsilon' \rangle.
\end{cases}
\]

Para aplicar este mecanismo, sí o sí necesitamos nuestras reglas semánticas de modo que apliquen los \textit{puntos estrictos} correspondientes usando \textbf{strict}. El resto de reglas se mantienen sin cambios, pero el cambio radica en que: aquellas expresiones donde detectamos la presencia de \textit{puntos estrictos} y recibian cerraduras de expresión ⟨e, $\varepsilon$⟩, es donde llamamos \textbf{strict}.

\section{Reglas semánticas perezosas con strict}

\begin{itemize}
\item NumV(n) :
$$\langle\text{NumV}(n), \varepsilon\rangle \to \langle\text{NumV}(n), \varepsilon\rangle$$

\item BoolV(b):
$$\langle\text{BoolV}(b), \varepsilon\rangle \to \langle\text{BoolV}(b), \varepsilon\rangle$$

\item AddV(i,d):
  $$
\frac{
  \text{strict}(i, \varepsilon) = \text{NumV}(n) \qquad \text{strict}(d, \varepsilon) = \text{NumV}(m)
}{
  \langle \text{AddV}(i, d), \varepsilon \rangle \to \langle \text{NumV}(n + m), \varepsilon \rangle
}
$$

\item SubV(i,d):
  $$
\frac{
  \text{strict}(i, \varepsilon) = \text{NumV}(n) \qquad \text{strict}(d, \varepsilon) = \text{NumV}(m)
}{
  \langle \text{SubV}(i, d), \varepsilon \rangle \to \langle \text{NumV}(n - m), \varepsilon \rangle
}
$$

\item MulV(i,d):
  $$
\frac{
  \text{strict}(i, \varepsilon) = \text{NumV}(n) \qquad \text{strict}(d, \varepsilon) = \text{NumV}(m)
}{
  \langle \text{MulV}(i, d), \varepsilon \rangle \to \langle \text{NumV}(n * m), \varepsilon \rangle
}
$$

\item DiV(i,d):
  $$
\frac{
  \text{strict}(i, \varepsilon) = \text{NumV}(n) \qquad \text{strict}(d, \varepsilon) = \text{NumV}(m)
}{
  \langle \text{DiV}(i, d), \varepsilon \rangle \to \langle \text{NumV}(n / m), \varepsilon \rangle
}
$$

$$
\frac{
  \text{strict}(d) = \text{NumV}(0)
}{
  \langle \text{DivV}(i, d), \varepsilon \rangle \to \text{Error}
}
$$

$$
\frac{
  \text{strict}(i) = \text{NumV}(n) \qquad \text{strict}(d) = \text{NumV}(m) \qquad m \neq 0
}{
  \langle \text{DivV}(i, d), \varepsilon \rangle \to \langle \text{NumV}(n/m), \varepsilon \rangle
}
$$

\item SqrtV(e):
$$
\frac{
  \text{strict}(e) = \text{NumV}(n) \qquad n < 0
}{
  \langle \text{SqrtV}(n), \varepsilon \rangle \to \text{Error}
}
$$

$$
\frac{
  \text{strict}(e) = \text{NumV}(n) \qquad n \geq 0
}{
  \langle \text{SqrtV}(e), \varepsilon \rangle \to \langle \text{NumV}(\sqrt{n}), \varepsilon \rangle
}
$$

\item NotV(e):
$$
\frac{
  \text{strict}(e) = \text{BoolV}(b) \qquad n \geq 0
}{
  \langle \text{NotV}(e), \varepsilon \rangle \to \langle \text{BoolV}{\not b}, \varepsilon \rangle
}
$$

\item EqualV(i,d)
$$
\frac{
  \text{strict}(i) = \text{NumV}(n) \qquad \text{strict}(d) = \text{NumV}(m)
}{
  \langle \text{EqualV}(i, d), \varepsilon \rangle \to \langle \text{BoolV}(n = m), \varepsilon \rangle
}
$$
  
\item LessV(i,d):
$$
\frac{
  \text{strict}(e_1) = \text{NumV}(n) \qquad \text{strict}(e_2) = \text{NumV}(m)
}{
  \langle \text{LessV}(e_1, e_2), \varepsilon \rangle \to \langle \text{BoolV}(n < m), \varepsilon \rangle
}
$$
  
\item DiffV(i,d):
$$
\frac{
  \text{strict}(e_1) = \text{NumV}(n) \qquad \text{strict}(e_2) = \text{NumV}(m)
}{
  \langle \text{DiffV}(e_1, e_2), \varepsilon \rangle \to \langle \text{BoolV}(n \neq m), \varepsilon \rangle
}
$$

\item LeqV(i,d):
$$
\frac{
  \text{strict}(e_1) = \text{NumV}(n) \qquad \text{strict}(e_2) = \text{NumV}(m)
}{
  \langle \text{LeqV}(e_1, e_2), \varepsilon \rangle \to \langle \text{BoolV}(n \le m), \varepsilon \rangle
}
$$

\item GeqV(i,d):
$$
\frac{
  \text{strict}(e_1) = \text{NumV}(n) \qquad \text{strict}(e_2) = \text{NumV}(m)
}{
  \langle \text{GeqV}(e_1, e_2), \varepsilon \rangle \to \langle \text{BoolV}(n \ge m), \varepsilon \rangle
}
$$

\item PairV(f,s):
$$
\langle \text{PairV}(f, s), \varepsilon \rangle \to \langle \text{PairV}(f, s), \varepsilon \rangle
$$

\item FstV(p):
$$
\frac{
  \text{strict}(p) = \text{PairV}(f, s)
}{
  \langle \text{FstV}(p), \varepsilon \rangle \to \langle f, \varepsilon \rangle
}
$$

\item SndV(p):
$$
\frac{
  \text{strict}(p) = \text{PairV}(f, s)
}{
  \langle \text{SndV}(p), \varepsilon \rangle \to \langle s, \varepsilon \rangle
}
$$
  
\item ConV(i,d):
$$
\langle \text{ConV}(i, d), \varepsilon \rangle \to \langle \text{ConV}(i, d), \varepsilon \rangle
$$
  
\item HeadV(l):
$$
\frac{
  \text{strict}(l) = \text{ConV}(i, d)
}{
  \langle \text{HeadV}(l), \varepsilon \rangle \to \langle i, \varepsilon \rangle
}
$$

\item TailV(l);
$$
\frac{
  \text{strict}(l) = \text{ConV}(i, d)
}{
  \langle \text{TailV}(l), \varepsilon \rangle \to \langle d, \varepsilon \rangle
}
$$

\item FunV(p,c):
$$
\langle \text{FunV}(p, c), \varepsilon \rangle \to \langle \text{Closure}(p, c, \varepsilon), \varepsilon \rangle
$$

\item AppV(f,a):
$$
\frac{
  \text{strict}(f) = \text{Closure}(p, c, \varepsilon')
}{
  \langle \text{AppV}(f, a), \varepsilon \rangle \to \langle c, \varepsilon'[p \leftarrow a] \rangle
}
$$
  
\end{itemize}

\begin{tcolorbox}[
    title=\textbf{Corrección},
    colframe=red!75!black,
    colback=red!5!white,
    fonttitle=\bfseries
]

\begin{itemize}

\item \textbf{Valores (NumV, BoolV):}
Se evalúan a sí mismos.
$$ \langle \text{NumV}(n), \varepsilon \rangle \Downarrow \text{NumV}(n) $$
$$ \langle \text{BoolV}(b), \varepsilon \rangle \Downarrow \text{BoolV}(b) $$

\item \textbf{AddV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m)
}{
  \langle \text{AddV}(i, d), \varepsilon \rangle \Downarrow \text{NumV}(n + m)
}
$$

\item \textbf{SubV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m)
}{
  \langle \text{SubV}(i, d), \varepsilon \rangle \Downarrow \text{NumV}(n - m)
}
$$

\item \textbf{MulV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m)
}{
  \langle \text{MulV}(i, d), \varepsilon \rangle \Downarrow \text{NumV}(n * m)
}
$$

\item \textbf{DiV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m) \quad m \neq 0
}{
  \langle \text{DiV}(i, d), \varepsilon \rangle \Downarrow \text{NumV}(n / m)
}
$$

$$
\frac{
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(0)
}{
  \langle \text{DivV}(i, d), \varepsilon \rangle \Downarrow \textbf{Error}
}
$$

\item \textbf{SqrtV(e):}
$$
\frac{
  \langle e, \varepsilon \rangle \Downarrow v_e \quad \text{strict}(v_e) = \text{NumV}(n) \quad n \geq 0
}{
  \langle \text{SqrtV}(e), \varepsilon \rangle \Downarrow \text{NumV}(\sqrt{n})
}
$$

$$
\frac{
  \langle e, \varepsilon \rangle \Downarrow v_e \quad \text{strict}(v_e) = \text{NumV}(n) \quad n < 0
}{
  \langle \text{SqrtV}(e), \varepsilon \rangle \Downarrow \textbf{Error}
}
$$

\item \textbf{NotV(e):}
$$
\frac{
  \langle e, \varepsilon \rangle \Downarrow v_e \quad \text{strict}(v_e) = \text{BoolV}(b)
}{
  \langle \text{NotV}(e), \varepsilon \rangle \Downarrow \text{BoolV}(\neg b)
}
$$

\item \textbf{EqualV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m)
}{
  \langle \text{EqualV}(i, d), \varepsilon \rangle \Downarrow \text{BoolV}(n = m)
}
$$

\end{itemize}
\end{tcolorbox}

\begin{tcolorbox}[
    title=\textbf{Corrección},
    colframe=red!75!black,
    colback=red!5!white,
    fonttitle=\bfseries
]
\begin{itemize}
\item \textbf{LessV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m)
}{
  \langle \text{LessV}(i, d), \varepsilon \rangle \Downarrow \text{BoolV}(n < m)
}
$$

\item \textbf{DiffV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m)
}{
  \langle \text{DiffV}(i, d), \varepsilon \rangle \Downarrow \text{BoolV}(n \neq m)
}
$$

\item \textbf{LeqV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m)
}{
  \langle \text{LeqV}(i, d), \varepsilon \rangle \Downarrow \text{BoolV}(n \le m)
}
$$

\item \textbf{GeqV(i,d):}
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = \text{NumV}(n) \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = \text{NumV}(m)
}{
  \langle \text{GeqV}(i, d), \varepsilon \rangle \Downarrow \text{BoolV}(n \ge m)
}
$$

\item \textbf{PairV(f,s):}
En la implementación estricta, se evalúan los componentes al construir el par:
$$
\frac{
  \langle f, \varepsilon \rangle \Downarrow v_f \quad \text{strict}(v_f) = v'_f \quad
  \langle s, \varepsilon \rangle \Downarrow v_s \quad \text{strict}(v_s) = v'_s
}{
  \langle \text{PairV}(f, s), \varepsilon \rangle \Downarrow \text{PairV}(v'_f, v'_s)
}
$$

\item \textbf{FstV(p):}
$$
\frac{
  \langle p, \varepsilon \rangle \Downarrow v_p \quad \text{strict}(v_p) = \text{PairV}(f, s)
}{
  \langle \text{FstV}(p), \varepsilon \rangle \Downarrow f
}
$$

\item \textbf{SndV(p):}
$$
\frac{
  \langle p, \varepsilon \rangle \Downarrow v_p \quad \text{strict}(v_p) = \text{PairV}(f, s)
}{
  \langle \text{SndV}(p), \varepsilon \rangle \Downarrow s
}
$$

\item \textbf{ConV(i,d):}
Similar a PairV, se fuerzan los componentes al construir la lista:
$$
\frac{
  \langle i, \varepsilon \rangle \Downarrow v_i \quad \text{strict}(v_i) = v'_i \quad
  \langle d, \varepsilon \rangle \Downarrow v_d \quad \text{strict}(v_d) = v'_d
}{
  \langle \text{ConV}(i, d), \varepsilon \rangle \Downarrow \text{ConV}(v'_i, v'_d)
}
$$

\item \textbf{HeadV(l):}
$$
\frac{
  \langle l, \varepsilon \rangle \Downarrow v_l \quad \text{strict}(v_l) = \text{ConV}(h, t)
}{
  \langle \text{HeadV}(l), \varepsilon \rangle \Downarrow h
}
$$

\item \textbf{TailV(l):}
$$
\frac{
  \langle l, \varepsilon \rangle \Downarrow v_l \quad \text{strict}(v_l) = \text{ConV}(h, t)
}{
  \langle \text{TailV}(l), \varepsilon \rangle \Downarrow t
}
$$

\end{itemize}
\end{tcolorbox}

\begin{tcolorbox}[
    title=\textbf{Corrección:},
    colframe=red!75!black,
    colback=red!5!white,
    fonttitle=\bfseries
]
\begin{itemize}
\item \textbf{FunV(p,c):}
Las funciones capturan el ambiente actual y se convierten en Closure.
$$
\langle \text{FunV}(p, c), \varepsilon \rangle \Downarrow \text{Closure}(p, c, \varepsilon)
$$

\item \textbf{AppV(f,a):}
Aquí radica la pereza. El argumento $a$ \textbf{no se evalúa}, sino que se guarda como un Thunk (\texttt{ExprV}) en el ambiente.
$$
\frac{
  \langle f, \varepsilon \rangle \Downarrow v_f \quad \text{strict}(v_f) = \text{Closure}(p, c, \varepsilon_{cl}) \quad
  \langle c, \varepsilon_{cl}[p \mapsto \text{ExprV}(a, \varepsilon)] \rangle \Downarrow v_{res}
}{
  \langle \text{AppV}(f, a), \varepsilon \rangle \Downarrow v_{res}
}
$$
\end{itemize}
\end{tcolorbox}

\begin{quote}
  \textit{Consultar la pagina 13-14 del ultimo pdf del profesor para ver contexto}
\end{quote}

Una vez definido todo lo anterior, veamos su implementación en Haskell y cómo se modifica el interprete de\minilisp .

\section{Evaluación perezosa para \minilisp}

Como se mostró, al cambiar la estrategia de evaluación de nuestro intérprete, debemos hacer muchos cambios en su implementación en Haskell.

Con este nuevo enfoque, nuestro tipo de dato \texttt{ASV} ya es más reducido donde solo están los valores canónicos:

\begin{lstlisting}[style=haskellstyle, caption={Tipo de dato \texttt{ASV} con valores canónicos}]
module ASV where

import AST

{--
Definimos la representacion del ambiente de ejecucion.
Un ambiente es una lista de pares (id, valor).
--}
type Env = [(String, ASV)]

{-- ASA Values --}
data ASV
  = NumV Int
  | BoolV Bool
  | NiV
  | PairV ASV ASV
  | ConV ASV ASV
  | ClosureF String AST Env
  | ExprV AST Env
  deriving (Show, Eq)
\end{lstlisting}

A diferencia de la implementación anterior, en este nuevo interprete ya no tenemos que usar la función \texttt{toFinalState} para convertir los \textbf{ASA} en estados finales, ya que los únicos estados finales son los valores canónicos ({Ambas definiciones significan lo mismo pero recordemos que en la primer implementación hicimos el abuso de notación para marcar la diferencia entre ambos}, de eso se encargará el nuevo intérprete, de convertir las expresion \texttt{AST} a estados finales (valores canónicos).\\

Definimos la función de evaluación perezosa con puntos estrictos como sigue:

\begin{lstlisting}[style=haskellstyle, caption={Evaluación perezosa con \textbf{strict} para\minilisp\hspace{-0.2cm}}]
module EvalStrict where

import AST
import ASV
import Interprete

{-- Funcion de evaluacion perezosa --}
evalS :: AST -> Env -> ASV
--Valores
evalS (VarC i) env = lookupS i env
evalS (NumC n) _   = (NumV n)
evalS (BoolC b) _  = (BoolV b)
evalS NiL _        = NiV
--Operadores aritmeticos
evalS (AddC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in NumV (numN i' + numN d')
evalS (SubC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in NumV (numN i' - numN d')
evalS (MulC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in NumV (numN i' * numN d')
evalS (DivC i d) env =
  let n = numN (strict (evalS i env))
      m = numN (strict (evalS d env))
   in if m == 0
        then error "No se puede dividir entre 0"
        else NumV (div n m)
evalS (SqrtC n) env =
  let n' = numN (strict (evalS n env))
   in if n' < 0
        then error "No se puede obtener la raiz de un numero negativo"
        else NumV (integerSquareRoot n')
--Not
evalS (NotC e) env =
  let e' = strict (evalS e env)
   in BoolV (not (boolN e'))
--Comparadores
evalS (EqualC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' == numN d')
evalS (LessC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' < numN d')
evalS (GreaterC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' > numN d')
evalS (DiffC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' /= numN d')
evalS (LeqC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' <= numN d')
evalS (GeqC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in BoolV (numN i' >= numN d')
--Pares
evalS (PairC i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in PairV i' d'
evalS (FstC p) env =
  case strict (evalS p env) of
    PairV f _ -> f
    _         -> error "Fst espera un par"
evalS (SndC p) env =
  case strict (evalS p env) of
    PairV _ s -> s
    _         -> error "Snd espera un par"
--Cons
evalS (ConS i d) env =
  let i' = strict (evalS i env)
      d' = strict (evalS d env)
   in ConV i' d'
evalS (HeadC p) env =
  case strict (evalS p env) of
    ConV h _ -> h
    _        -> error "Head espera una lista"
evalS (TailC p) env =
  case strict (evalS p env) of
    ConV _ t ->
      let t' = strict t
       in if not (isConV t')
          then t'
          else tailDeep t'
    _        -> error "Tail espera una lista"
--If
evalS (IfC c t e) env =
  let cond = boolN (strict (evalS c env))
   in if cond then evalS t env else evalS e env
--Funciones
evalS (FunC p c) env = ClosureF p c env
--Aplicacion de funciones
evalS (AppC f a) env =
  let f' = evalS f env
      funV = strict f'
   in evalS (closureC funV) (((closureP funV), ExprV a env) : (closureE funV))

{-- Funcion strict para forzar la evaluacion de los puntos estrictos --}
strict :: ASV -> ASV
strict (NumV n) = NumV n
strict (BoolV b) = BoolV b
strict (PairV f s) = PairV (strict f) (strict s)
strict (ConV i d) = ConV (strict i) (strict d)
strict (ExprV a e) = strict (evalS a e)
strict (NiV) = NiV
strict (ClosureF p c e) = ClosureF p c e

{-- Funcion auxiliar para devolver el numero de NumV--}
numN :: ASV -> Int
numN (NumV n) = n

{-- Funcion auxiliar para devolver el booleano de BoolV --}
boolN :: ASV -> Bool
boolN (BoolV b) = b
boolN _ = False

{-- Funcion auxiliar para devoler el parametro de la cerradura --}
closureP :: ASV -> String
closureP (ClosureF p _ _) = p

{-- Funcion auxiliar para devoler el cuerpo de la cerradura --}
closureC :: ASV -> AST
closureC (ClosureF _ c _) = c

{-- Funcion auxiliar para devoler el ambiente de la cerradura --}
closureE :: ASV -> Env
closureE (ClosureF _ _ e) = e

{-- Funcion auxiliar para encontrar el ultimo elemento canonico de los ConV anidados--}
tailDeep :: ASV -> ASV
tailDeep (ConV _ rest) =
  let rest' = strict rest
  in if not (isConV rest')
     then rest'
     else tailDeep rest'
tailDeep v = v

\end{lstlisting}

La mayor diferencia a \texttt{eval} es que la función \texttt{evalS} ya no utiliza la evaluación de paso pequeño, sino que implementa una evaluación directa (\textit{\textbf{big-step}}). Ahora utilizamos funciones auxiliares (\texttt{strict}, \texttt{numN}, \texttt{boolN}, etc.) para obtener valores “$forzados$”.

\noindent
Además de este cambio, lo más notorio es \texttt{TailC} y la aplicación de funciones. La primer expresión ahora utiliza una función auxiliar \texttt{tailDeep} para seguir buscando el último elemento en la anidación de \texttt{ConS}, ya que usar \texttt{evalS} nos da una inconsistencia de tipos, pues al evaluar por primera vez el par, este se transforma en un \texttt{ASV} siendo que \texttt{evalS} recibe \texttt{AST}.

\noindent
Para el caso de \texttt{AppC}:

\begin{enumerate}
\item Evalúa $f$ en el ambiente actual, esto debería devolver una cerradura.
\item Fuerza \textit{f'} con \texttt{strict}, asegurándose de que sea una cerradura concreta.
\item Extrae información de la cerradura:
  \begin{itemize}
  \item \texttt{closureC funV}: el cuerpo de la función.
  \item \texttt{closureP funV}: el nombre del parámetro formal.
  \item \texttt{closureE funV}: el ambiente donde la función fue creada.
\end{itemize}

\item Crea un nuevo ambiente donde:
  \begin{itemize}
  \item El parámetro formal (\texttt{closureP funV}) se asocia a la expresión real (\texttt{ExprV a env});
  \item Se añade al ambiente original de la cerradura (\texttt{closureE funV}).
  \end{itemize}
  
\item Evalúa el cuerpo de la función (\texttt{closureC funV}) en ese nuevo ambiente extendido.
\end{enumerate}

De este modo tenemos una evaluación adecuada para introducir recursión con \texttt{LetRec} en nuestro lenguaje\minilisp\hspace{-0.2cm}, pues como mencionamos, necesitamos meter al ambiente inicial la evaluación de nuestro combinador Z, el cuál se mostró que presentaba errores con la evaluación glotona.

\section{Cierre: intérprete, recursión y evaluación glotona}

En este capítulo hemos introducido la idea de \emph{puntos estrictos} y la operación meta-semántica \textbf{strict} para mezclar evaluación perezosa con los contextos que requieren valores canónicos. Antes de terminar, conviene cerrar con tres observaciones importantes relacionadas con la representación de cierres en el intérprete, el tratamiento de la recursión y el contraste con la evaluación \emph{glotona} (estricta).

\subsection{Cierre del intérprete (closures)}
Un intérprete funcional perezoso debe representar funciones como \emph{closures} que capturan su ambiente léxico en el momento de la creación. Formalmente, una función se convierte en el valor
\[
Closure(p,c,\varepsilon)
\]
donde \(p\) es el parámetro (o patrón), \(c\) el cuerpo y \(\varepsilon\) el ambiente en el que la función fue creada. Esta representación garantiza que, al aplicar la función, las referencias libres del cuerpo se resuelvan respecto al ambiente léxico original.

En un intérprete real (implementación), un closure típicamente contiene:
\begin{itemize}
  \item el código del cuerpo (o un puntero/índice a ese código);
  \item un mapa de identidades a valores diferidos (thunks) o valores ya evaluados;
  \item una semántica consistente para la sustitución o enlace del parámetro con el argumento.
\end{itemize}

\subsection{Recursión y combinadores}
La recursión puede introducirse de varias maneras:
\begin{enumerate}
  \item \textbf{Ligada (letrec / definiciones recursivas)}: extiende el ambiente con una entrada que referencia una celda que puede actualizarse o auto-referenciarse\cite{landsman}.
  \item \textbf{Combinadores de punto fijo (por ejemplo \(Y\))}: expresan la recursión sin nombres mediante un combinador que produce un punto fijo de funciones\cite{Baren-Lambda}.
\end{enumerate}

Es importante destacar la diferencia de comportamiento del combinador \(Y\) según la estrategia de evaluación:

\paragraph{Estrategia perezosa.} Con evaluación perezosa, el combinador \(Y\) puede ser útil porque el desempaquetado del punto fijo se hace cuando el cuerpo lo requiere, permitiendo definiciones recursivas sin evaluación inmediata que provoque bucles infinitos. Por eso, muchas construcciones recursivas clásicas basadas en \(Y\) funcionan en lenguajes perezosos\cite{Baren-Lambda}.

\paragraph{Estrategia glotona (estricta).} En evaluación estricta, el uso directo del combinador \(Y\) clásico provoca normalmente no-terminación: la autoinvocación se expande inmediatamente y nunca alcanza un punto en que se pueda seguir computando. Para obtener recursión en un lenguaje estricto se suele necesitar:
\begin{itemize}
  \item \texttt{letrec} o \texttt{fix} implementado con celdas mutables (o un mecanismo de enlace que permita referencias a sí mismo), o
  \item transformar las definiciones mediante técnicas como \emph{lambda-lifting} o introducir explícitamente una celda recursiva (thunk auto-referente) que posponga la evaluación.
\end{itemize}

\subsubsection*{Ejemplo informal}
Sea la definición recursiva factorial, expresada con un combinador de punto fijo:
\[
fact = Y(\lambda f.\ \lambda n.\ \text{if } n = 0 \text{ then } 1 \text{ else } n * f(n-1)).
\]
En evaluación perezosa, las llamadas a \(f\) se fuerzan sólo cuando es necesario, y \(Y\) puede comportarse adecuadamente. En evaluación estricta, la expansión de \(Y\) genera una evaluación infinita antes de que se alcance alguna condición base, salvo que se use una forma de \texttt{letrec} o una celda recursiva.

\subsection{Evaluación glotona (estricta): reglas contrastantes}
Para clarificar el contraste con la semántica perezosa con \textbf{strict}, presentamos una versión compacta de la regla de aplicación en evaluación estricta (call-by-value), que ilustra la diferencia con la regla lazy que usamos antes.

\[
\frac{\langle f, \varepsilon\rangle \to^* \langle Closure(p,c,\varepsilon_f),\varepsilon\rangle \qquad
      \langle a, \varepsilon\rangle \to^* \langle v_a,\varepsilon\rangle}
     {\langle AppV(f,a),\varepsilon\rangle \to \langle c,\; \varepsilon_f[p\leftarrow v_a]\rangle}
\]

En palabras: en evaluación estricta evaluamos primero \textbf{la función} hasta obtener un closure y \textbf{el argumento} hasta obtener un valor canónico \(v_a\); sólo entonces realizamos la sustitución/enlace del parámetro. Esto contrasta con la regla lazy:

\[
\frac{strict(f)=Closure(p,c,\varepsilon_f)}
     {\langle AppV(f,a),\varepsilon\rangle \to \langle c,\; \varepsilon_f[p\leftarrow a]\rangle}
\]
donde en el segundo miembro \emph{no} se evalúa \(a\) al aplicar: se guarda la expresión \(a\) (thunk) en el ambiente del closure.

\subsection{Cierre}
Con esto concluimos el tratamiento de los puntos estrictos y su integración en la semántica de \minilisp. Hemos mostrado cómo conservar la pereza por defecto mientras forzamos evaluación en contextos donde es necesaria, y cómo este diseño afecta la representación de cierres, la forma de implementar recursión y las diferencias prácticas frente a una semántica glotona. En capítulos posteriores podremos:
\begin{itemize}
  \item mostrar la implementación concreta de \textbf{strict} en el intérprete (código y gestión de thunks),
  \item dar ejemplos paso a paso de evaluación de expresiones recursivas bajo ambas estrategias, y
  \item discutir optimizaciones (memoización de thunks, eliminación de thunks no necesarios, etc.).
\end{itemize}

