\chapter{Semántica Operacional}
Una vez que hemos establecido la sintaxis del lenguaje en sus formas núcleo, el siguiente paso es proporcionar significado formal a los programas: 
especificar cómo deben ejecutarse y cuál es el resultado de cada construcción del lenguaje. Para ello recurrimos a la \emph{semántica operacional}, un enfoque formal que describe el comportamiento de los programas mediante reglas que modelan su ejecución paso a paso o de manera global.


La formalización de la semántica permite razonar rigurosamente sobre programas, verificar propiedades (por ejemplo corrección y seguridad), y relacionar la especificación formal con una implementación (intérprete o compilador). Existen distintos enfoques para dar semántica a un lenguaje (operacional, denotacional y axiomática). En este trabajo nos centraremos en la semántica operacional y, concretamente, en el estilo \emph{small-step} (semántica estructural), que es el más conveniente para \minilisp por su claridad al exponer transformaciones intermedias.


\section{¿Qué es la semántica operacional?}
La semántica operacional especifica el significado de los programas describiendo cómo estos evolucionan durante su ejecución. En lugar de asignar directamente un valor matemático al programa, se define un sistema de reglas de inferencia que muestran cómo un programa avanza desde un estado inicial hasta un estado final (o intermedio). Cada regla representa un paso válido de evaluación en el lenguaje.
Este enfoque permite expresar la dinámica del programa de manera clara, estructural y verificable, lo que resulta especialmente útil para lenguajes funcionales como \minilisp.

Dos estilos comunes son:
\begin{itemize}
\item\textbf{Semántica Natural (Big-step)}
La \textit{semántica natural}, también llamada \textit{big-step}, evalúa expresiones completas en una sola derivación, directamente desde el programa inicial hasta el valor final. Es decir, describe qué resultado obtiene un programa, sin enfocarse en cada uno de los pasos intermedios.
\end{itemize}

\begin{quote}
  Fue introducida por Gordon Plotkin en 1981 como parte de su trabajo fundacional en semántica estructural.
 Describe la evaluación completa de los programas.~\cite{Plotkin}
\end{quote}

\begin{itemize}
\item\textbf{Semántica Estructural (Small-step)}
La \textit{semántica estructural}, también conocida como \textit{small-step}, especifica la evaluación como una secuencia de pasos pequeños, donde cada regla transforma una expresión en otra más simple hasta llegar a un valor final.
\end{itemize}

Se abordara a detalle su historia mas adelante.

\textit{Elección del enfoque para MiniLisp}
Para nuestro lenguaje \minilisp utilizaremos la semántica operacional de estilo \textit{small-step}, ya que este enfoque nos permite observar y controlar cada transformación intermedia del programa, lo cual es ideal para entender con precisión el proceso de evaluación y para implementar un intérprete paso a paso.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Semántica Estructural (Paso pequeño)}
La \textbf{semántica estructural de paso pequeño} (\textit{small-step operational semantics}) describe la ejecución de los programas como una secuencia de transiciones elementales. En este enfoque, el significado de un programa no se define únicamente por su resultado final, sino por la sucesión de configuraciones que atraviesa durante su evaluación. Cada paso representa una transformación mínima y formalmente justificada sobre una expresión, lo que permite capturar con precisión el proceso computacional.

Formalmente, esta semántica define una relación de transición:
\[
e \;\longrightarrow\; e'
\]
que indica que la expresión \(e\) evoluciona en un solo paso a la expresión \(e'\). La relación de evaluación completa se obtiene mediante la clausura reflexivo–transitiva:
\[
e \;\longrightarrow^{*}\; v
\]
donde \(v\) es un valor.  

Este enfoque fue sistematizado por Gordon Plotkin como parte del marco \textbf{Structural Operational Semantics (SOS)}~\cite{Plotkin}, el cual enfatiza la correspondencia directa entre la estructura sintáctica del lenguaje y sus reglas de evaluación. La semántica de paso pequeño resulta especialmente útil en el estudio de lenguajes funcionales como \minilisp, donde el orden de evaluación, la sustitución y la estructura de funciones juegan un papel esencial en la ejecución.

\subsection*{Motivos para emplear la semántica de paso pequeño}
Optar por este estilo semántico ofrece varias ventajas:
\begin{itemize}
  \item \textbf{Claridad sobre el proceso de ejecución}: permite observar cada paso de la evaluación, en contraste con la semántica de \textit{big-step}, que solo muestra el estado inicial y el resultado final.
  \item \textbf{Modelo fiel para intérpretes}: las reglas se traducen casi directamente en algoritmos, facilitando la implementación de un intérprete paso a paso.
  \item \textbf{Razonamiento formal detallado}: es más adecuada para estudiar propiedades como determinismo, progresión, preservación de tipos, y analizar comportamientos intermedios.
  \item \textbf{Adecuada para depuración y evaluación interactiva}: permite observar el flujo de ejecución e inspeccionar expresiones intermedias, lo cual es crucial para sistemas educativos e intérpretes interactivos.
\end{itemize}

En el contexto de \minilisp, la semántica de paso pequeño nos permite capturar explícitamente cómo las expresiones se reducen, aplicando reglas como la reducción \(\beta\), la evaluación de condicionales, y la expansión de funciones recursivas. Esta formalización establece la base teórica para la implementación del intérprete desarrollado en este proyecto.


\subsection{Sistema de transición}

Para modelar formalmente la ejecución de nuestro lenguaje, utilizamos un \textbf{sistema de transición}. Este marco matemático permite describir cómo un programa evoluciona paso a paso mediante la aplicación de reglas de reducción.

Un \textbf{sistema de transición} es una tupla \((E, \rightarrow, I, F)\) donde:

\begin{itemize}
  \item \(E\) es el conjunto (posiblemente infinito) de \textbf{estados} del sistema.
  \item \(\rightarrow \subseteq E \times E\) es la \textbf{relación de transición}, que indica cómo un estado puede transformarse en otro.
  \item \(I \subseteq E\) es el conjunto de \textbf{estados iniciales}, desde los cuales comienza la ejecución.
  \item \(F \subseteq E\) es el conjunto de \textbf{estados finales}, es decir, aquellos estados donde la ejecución se considera terminada.
\end{itemize}

La ejecución de un programa se modela entonces como una secuencia de transiciones:

\[
e_0 \;\rightarrow\; e_1 \;\rightarrow\; e_2 \;\rightarrow\; \cdots \;\rightarrow\; e_n
\]

donde \(e_0 \in I\), cada transición \(e_i \rightarrow e_{i+1}\) está justificada por una regla de evaluación, y \(e_n \in F\) representa un estado final.

En el contexto de \minilisp, usaremos este formalismo para describir cómo las expresiones del lenguaje se transforman gradualmente hasta producir un valor o alcanzar una condición de término. Los \textbf{estados finales} corresponderán a valores que ya no pueden seguir reduciéndose, tales como números, valores booleanos, funciones evaluadas y otras construcciones que definiremos formalmente más adelante.


\subsubsection*{Sobre la noción de cerradura (closure)}

Un elemento fundamental en la semántica de lenguajes funcionales es la \textbf{cerradura} o \textit{closure}. Una closure es una representación formal de una función junto con el entorno léxico en el cual fue definida. Esto significa que, además del cuerpo de la función, se almacena la información necesaria para interpretar correctamente sus variables libres.

\[
\text{closure} = \langle \lambda x.\, e,\; \rho \rangle
\]

donde:

\begin{itemize}
  \item \(\lambda x.\, e\) es una expresión lambda, es decir, la definición de la función.
  \item \(\rho\) es un \textbf{ambiente léxico} que mapea variables a valores.
\end{itemize}

Las closures permiten implementar correctamente \textit{scoping léxico}, asegurando que las funciones mantengan acceso a las variables del contexto donde fueron creadas, aun cuando se utilicen fuera de dicho contexto. Aunque mencionamos este concepto aquí, su definición formal y su rol dentro de los estados finales se precisará en secciones posteriores.


\subsection{Estados Finales en\minilisp}

Definimos los estados finales para el lenguaje\minilisp{-0.2cm}:
\begin{align*}
  F = &\{\, Num_{V}(n) \mid n \in \Z\,\}\: \cup \:\{\, Boolean_{V}(b) \mid b \in \{True,False\}\,\}\: \cup \:\{\, Pair_{V}(f,s) \mid f,s\in F\,\}\: \cup \\
  &\{\, Cons_{V}(h,t) \mid h,t\in C\,\}\: \cup \:\{\, Nil_{V} \mid \text{ es la lista vacía}\}\: \cup \\
  &\{\, Closure (f,\varepsilon) \mid f \text{ es una función y } \varepsilon\text{ es un ambiente léxico}\}
\end{align*}

Intuitivamente implementamos los estados finales en nuestro lenguaje como un tipo de dato en Haskell:

\begin{lstlisting}[style=haskellstyle, caption={Tipo de dato ASV, representan los estados finales}]
module ASV where

-- ASA Values
data ASV
  = VarV String
  | NumV Int
  | BoolV Bool
  | NiV
  | PairV ASV ASV
  | ConV ASV ASV
  | Closure String ASV [(String, ASV)]
  deriving (Show, Eq)
\end{lstlisting}

El tipo de dato \texttt{ASV} serán con el que modelaremos los estados finales del lenguaje. Sin embargo, en nuestra implementación, es necesario agregar las demás estructuras que trabajan con estos estados finales -como lo son los operadores aritméticos o las operaciones sobre pares o listas- ya que \texttt{ASV} sigue modelando una estructura de tipo árbol la cual sigue el mismo principio que las estructuras \texttt{ASA}:

\begin{center}
  \textit{Una expresión es \texttt{ASV} si y solo si sus hijos también son \texttt{ASV}.}
\end{center}

Por lo que debemos hacer que nuestros Para diferenciar entre los verdaderos estados finales y las demás estructuras de tipo \texttt{ASV} será que nos referimos a los finales como \textit{\textbf{valores canónicos}}.\footnote{Más adelante enfatizaremos en como los diferenciamos entre Valores \texttt{ASV} y expresiones \texttt{ASV} en Haskell.}
Lo que nos queda en la nueva definición del tipo de dato \texttt{ASV}:

\begin{lstlisting}[style=haskellstyle, caption={Tipo de dato ASV completo}]
-- ASA Values
data ASV
  = VarV String
  | NumV Int
  | BoolV Bool
  | NiV
  | AddV ASV ASV
  | SubV ASV ASV
  | MulV ASV ASV
  | DiV ASV ASV
  | SqrtV ASV
  | NotV ASV
  | EqualV ASV ASV
  | LessV ASV ASV
  | GreaterV ASV ASV
  | DiffV ASV ASV
  | LeqV ASV ASV
  | GeqV ASV ASV
  | PairV ASV ASV
  | FstV ASV
  | SndV ASV
  | IfV ASV ASV ASV
  | FunV String ASV
  | AppV ASV ASV
  | ConV ASV ASV
  | HeadV ASV
  | TailV ASV
  | Closure String ASV [(String, ASV)]
  deriving (Show, Eq)
\end{lstlisting}

Ya que hemos definido el tipo de dato \texttt{ASV} veamos como convertimos nuestras estructuras \texttt{AST} a estados finales \texttt{ASV}:

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{toFinalState} que transforma los núcleos \texttt{AST} a estados finales \texttt{ASV}}]
  {-- Convertimos los AST a estados finales ASV --}
  toFinalState :: AST -> ASV
  toFinalState (VarC x) = VarV x
  toFinalState (NumC n) = NumV n
  toFinalState (BoolC b) = BoolV b
  toFinalState (AddC i d) = AddV (toFinalState i) (toFinalState d)
  toFinalState (SubC i d) = SubV (toFinalState i) (toFinalState d)
  toFinalState (MulC i d) = MulV (toFinalState i) (toFinalState d)
  toFinalState (DivC i d) = DiV (toFinalState i) (toFinalState d)
  toFinalState (SqrtC n) = SqrtV (toFinalState n)
  toFinalState (NotC x) = NotV (toFinalState x)
  toFinalState (EqualC i d) = EqualV (toFinalState i) (toFinalState d)
  toFinalState (LessC i d) = LessV (toFinalState i) (toFinalState d)
  toFinalState (GreaterC i d) = GreaterV (toFinalState i) (toFinalState d)
  toFinalState (DiffC i d) = DiffV (toFinalState i) (toFinalState d)
  toFinalState (LeqC i d) = LeqV (toFinalState i) (toFinalState d)
  toFinalState (GeqC i d) = GeqV (toFinalState i) (toFinalState d)
  toFinalState (PairC f s) = PairV (toFinalState f) (toFinalState s)
  toFinalState (FstC p) = FstV (toFinalState p)
  toFinalState (SndC p) = SndV (toFinalState p)
  toFinalState (ConS f s) = ConV (toFinalState f) (toFinalState s)
  toFinalState (HeadC p) = HeadV (toFinalState p)
  toFinalState (TailC p) = TailV (toFinalState p)
  toFinalState (IfC c t e) = IfV (toFinalState c) (toFinalState t) (toFinalState e)
  toFinalState (FunC p b) = FunV p (toFinalState b)
  toFinalState (AppC f a) = AppV (toFinalState f) (toFinalState a)
  toFinalState NiL = NiV
\end{lstlisting}

La función \texttt{toFinalState} transforma cada estructura del núcleo AST en su equivalente ASV. Aunque a primera vista parezca una simple correspondencia entre constructores, su propósito es fundamental: garantizar que todas las expresiones que se evalúan dentro del intérprete sean expresadas en términos de ASV, permitiendo así que la semántica del lenguaje opere únicamente sobre estructuras homogéneas y compatibles con los valores finales del lenguaje.

\subsection{Reglas de evaluación}

Las reglas de evaluación constituyen el núcleo de la semántica operacional estructural. Su propósito es describir formalmente cómo una expresión del lenguaje progresa paso a paso hasta convertirse en un valor. Cada regla establece una relación de transición entre estados del programa, donde un estado suele estar compuesto por una expresión y un ambiente (o entorno) de ejecución.

Estas reglas son necesarias porque proporcionan una base rigurosa para entender, implementar y razonar formalmente sobre el comportamiento de un lenguaje de programación. Al definir el significado de un programa mediante reglas inductivas, aseguramos que cada paso de cómputo esté claramente especificado y sea verificable. Además, permiten demostrar propiedades importantes como corrección, determinismo, o progresión de los programas.

Un componente fundamental en esta formalización es el ambiente ($\varepsilon$), que modela el contexto donde se evalúan las expresiones. El ambiente es una estructura que asocia identificadores del lenguaje con valores, y se actualiza o consulta durante la evaluación. En esencia, actúa como una memoria que mantiene las asignaciones vigentes en cada punto del cómputo. Las reglas operan entonces sobre pares $\langle \text{expresión}, \varepsilon \rangle$, indicando cómo se transforma la expresión manteniendo o modificando dicho ambiente.

\begin{itemize}
\item Expresiones atómicas:
  \begin{itemize}
  \item VarV(i):
    \[
    \frac{lookup\ i\ \varepsilon = v}{\langle VarV(i), \varepsilon \rangle \to \langle v, \varepsilon \rangle}
    \]
    \[
    \frac{lookup\ i\ \varepsilon \ \text{no está definido}}{\langle Varv(i), \varepsilon \rangle \to \text{Error en la ejecución de la evaluación}}
    \]

El operador \texttt{lookup} busca el valor asociado a un identificador dentro del ambiente \(\varepsilon\). Si el identificador se encuentra definido, \texttt{lookup} devuelve su valor; en caso contrario, la evaluación produce un error, ya que se intenta acceder a una variable no declarada o fuera de su alcance. De esta manera, \texttt{lookup} garantiza que toda referencia a variables se resuelva correctamente según el entorno léxico vigente.

    
  \item NumV(n):
    \[
    \frac{}{\langle NumV(n), \varepsilon \rangle \to \langle NumV(n), \varepsilon \rangle}
    \]
    
  \item BoolV(b):
    \[
    \frac{}{\langle BoolV(b), \varepsilon \rangle \to \langle BoolV(b), \varepsilon \rangle}
    \]
  \item NiV:
    \[
    \frac{}{\langle NivV, \varepsilon \rangle \to \langle NiV, \varepsilon \rangle}
    \]
  \end{itemize}
  
\item AddV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle AddV(i,d), \varepsilon \rangle \to \langle AddV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle AddV(NumV(n),d), \varepsilon \rangle \to \langle Add(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle AddV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n +_{\Z} m), \varepsilon \rangle}
  \]
  
\item SubV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle SubV(i,d), \varepsilon \rangle \to \langle SubV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle SubV(NumV(n),d), \varepsilon \rangle \to \langle SubV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle SubV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n -_{\Z} m), \varepsilon \rangle}
  \]
 
\item MulV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle MulV(i,d), \varepsilon \rangle \to \langle MulV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle MulV(NumV(n),d), \varepsilon \rangle \to \langle MulV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle MulV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n *_{\Z} m), \varepsilon \rangle}
  \]
  
\item DiV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle DiV(i,d), \varepsilon \rangle \to \langle DiV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle DiV(NumV(n),d), \varepsilon \rangle \to \langle DiV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle DiV(NumV(n),NumV(0)), \varepsilon \to \text{Error en la ejecución de la evaluación}}
  \]
  \[
  \frac{}{ \langle DiV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n\ /_{\Z}\ m), \varepsilon \rangle} \quad (m \neq 0)
  \]
  
\item SqrtV(n):
  \[
  \frac{\langle n, \varepsilon \rangle \to \langle n', \varepsilon \rangle}{\langle SqrtV(n), \varepsilon \rangle \to \langle SqrtV(n'), \varepsilon \rangle}
  \]
  \[
  \frac{n < 0}{\langle SqrtV(NumV(n)), \varepsilon \to \text{Error en la ejecución de la evaluación}}
  \]
  \[
  \frac{}{\langle SqrtV(NumV(n)), \varepsilon \rangle \to \langle NumV(\sqrt{n}_{\N}), \varepsilon \rangle}  \quad (n \geq 0)
  \]
  
\item NotV(b):
  \[
  \frac{\langle b, \varepsilon \rangle \to \langle n', \varepsilon \rangle}{\langle NotV(b), \varepsilon \rangle \to \langle NotV(b'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle NotV(BoolV(b)), \varepsilon \rangle \to \langle BoolV(\neg_{\P}b) \varepsilon \rangle}
  \]
  
\item EqualV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle EqualV(i,d), \varepsilon \rangle \to \langle EqualV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle EqualV(NumV(n),d), \varepsilon \rangle \to \langle EqualV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle EqualV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n =_{\Z} m), \varepsilon \rangle}
  \]

\item LessV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle LessV(i,d), \varepsilon \rangle \to \langle LessV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle LessV(NumV(n),d), \varepsilon \rangle \to \langle LessV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle LessV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n <_{\Z} m), \varepsilon \rangle}
  \]
  
\item GreaterV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle GreaterV(i,d), \varepsilon \rangle \to \langle GreaterV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle GreaterV(NumV(n),d), \varepsilon \rangle \to \langle GreaterV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle GreaterV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n >_{\Z} m), \varepsilon \rangle}
  \]
  
\item DiffV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle DiffV(i,d), \varepsilon \rangle \to \langle DiffV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle DiffV(NumV(n),d), \varepsilon \rangle \to \langle DiffV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle DiffV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n \neq_{\Z} m), \varepsilon \rangle}
  \]
  
\item LeqV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle LeqV(i,d), \varepsilon \rangle \to \langle LeqV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle LeqV(NumV(n),d), \varepsilon \rangle \to \langle LeqV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle LeqV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n \leq_{\Z} m), \varepsilon \rangle}
  \]
  
\item GeqV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle GeqV(i,d), \varepsilon \rangle \to \langle GeqV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle GeqV(NumV(n),d), \varepsilon \rangle \to \langle GeqV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle GeqV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n \geq_{\Z} m), \varepsilon \rangle}
  \]
\end{itemize}

Como se puede ver en las reglas para los comparadores, la regla final cuando ambas expresiones del comparador son el resultado deriva en

\begin{itemize}  
\item PairV(f,s):
  \[
  \frac{\langle f, \varepsilon \rangle \to \langle f', \varepsilon \rangle}{\langle PairV(f,s), \varepsilon \rangle \to \langle PairV(f',s), \varepsilon \rangle}
  \]
  \[
  \frac{\langle s, \varepsilon \rangle \to \langle s', \varepsilon \rangle}{\langle PairV(v_f,s), \varepsilon \rangle \to \langle PairV(v_f,s'), \varepsilon \rangle}
  \]
  \[
  \frac{v_f, v_s \text{ son valores canónicos}}{\langle PairV(v_f,v_s), \varepsilon \rangle \to \langle PairV(v_f,v_s), \varepsilon \rangle}
  \]
  
\item FstV(p):
  \[
  \frac{\langle p, \varepsilon \rangle \to \langle p', \varepsilon \rangle}{\langle FstV(p), \varepsilon \rangle \to \langle FstV(p'), \varepsilon \rangle}
  \]
  \[
  \frac{v_1, v_2 \text{ son valores canónicos}}{\langle FstV(PairV(v_1,v_2)), \varepsilon \rangle \to \langle v_1, \varepsilon \rangle}
  \]
  
\item SndV(p):
  \[
  \frac{\langle p, \varepsilon \rangle \to \langle p', \varepsilon \rangle}{\langle SndV(p), \varepsilon \rangle \to \langle SndV(p'), \varepsilon \rangle}
  \]
  \[
  \frac{v_1, v_2 \text{ son valores canónicos}}{\langle SndV(PairV(v_1,v_2)), \varepsilon \rangle \to \langle v_2, \varepsilon \rangle}
  \]
  
\item IfV(c,t,e), IfV solo evalúa la condicional hasta llegar a un \texttt{BoolV} mas no evalúa el \textbf{then} o \textbf{else} dependiendo del resultado de la condición, solo se encarga de retornar alguno de los dos dependiendo del caso:
  \[
  \frac{\langle c, \varepsilon \rangle \to \langle c', \varepsilon \rangle}{\langle IfV(c,t,e), \varepsilon \rangle \to \langle IfV(c',t,e), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle IfV(BoolV(\#t),t,e), \varepsilon \rangle \to \langle t, \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle IfV(BoolV(\#f),t,e), \varepsilon \rangle \to \langle e, \varepsilon \rangle}
  \]
  
\item ConV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle ConV(i,d), \varepsilon \rangle \to \langle ConV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{v_i \text{ es valor canónico} \; \langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle ConV(v_i,d), \varepsilon \rangle \to \langle ConV(v_i,d'), \varepsilon \rangle}
  \]
  \[
  \frac{v_i, v_d \text{ son valores canónicos}}{\langle ConV(v_i,v_d), \varepsilon \rangle \to \langle ConV(v_i,v_d), \varepsilon \rangle}
  \]
  
\item HeadV(l):
  \[
  \frac{\langle p, \varepsilon \rangle \to \langle p', \varepsilon \rangle}{\langle HeadV(l), \varepsilon \rangle \to \langle HeadV(l'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle HeadV(ConV(v_i,v_d)), \varepsilon \rangle \to \langle v_i, \varepsilon \rangle}
  \]
  
\item TailV(l);
  \[
  \frac{\langle l, \varepsilon \rangle \to \langle l', \varepsilon \rangle}{\langle TailV(l), \varepsilon \rangle \to \langle TailV(l'), \varepsilon \rangle}
  \]
  \[
  \frac{v_d \text{ es valor pero } v_d = ConV(i,d) \;\; v_d \to v_d'}{\langle TailV(ConV(v_i,v_d)), \varepsilon \rangle \to \langle TailV(v_i,v_d'), \varepsilon \rangle}
  \]
  \[
  \frac{v_d \text{ es valor pero} v_d \neq ConV(i,d)}{\langle TailV(ConV(v_i,v_d)), \varepsilon \rangle \to \langle v_d, \varepsilon \rangle}
  \]
  
\item FunV(p,c):
  \[
  \frac{}{\langle FunV(p,c), \varepsilon \rangle \to \langle Closure(FunV(p,c), \varepsilon), \varepsilon \rangle}
  \]
  
\item AppV(f,a):
  \[
  \frac{\langle f, \varepsilon \rangle \to \langle f', \varepsilon \rangle}{\langle AppV(f,a), \varepsilon \rangle \to \langle AppV(f',a), \varepsilon \rangle}
  \]
  \[
  \frac{\langle a, \varepsilon \rangle \to \langle a', \varepsilon \rangle}{\langle AppV(Closure(FunV(p,c), \varepsilon'),a), \varepsilon \rangle \to \langle AppV(Closure(FunV(p,c), \varepsilon'),a'), \varepsilon \rangle}
  \]
  \[
  \frac{\^{a} \text{ es un valor canónico}}{\langle AppV(Closure(FunV(p,c), \varepsilon'), \^{a}), \varepsilon \rangle \to \langle c, \varepsilon'[p \leftarrow \^{a}] \rangle}
  \]
\end{itemize}

\subsubsection*{Conclusión}
  En resumen, las reglas de evaluación proporcionan el marco formal necesario para describir con precisión el proceso de ejecución de los programas dentro de un lenguaje. A través de estas reglas se establece, de manera inductiva, cómo las expresiones evolucionan paso a paso bajo un ambiente de evaluación, garantizando así un comportamiento bien definido y verificable. Este enfoque no solo facilita la implementación y el razonamiento formal del lenguaje, sino que también permite identificar errores semánticos de forma rigurosa, asegurando que cada etapa del cómputo sea consistente con la semántica especificada.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Intérprete para\minilisp}

Una vez definida formalmente la Semántica Operacional Estructural para nuestro lenguaje, estamos en posición de implementar un intérprete que materialice dicha semántica en código. El propósito del intérprete es ejecutar programas escritos en nuestro \minilisp, aplicando las reglas de evaluación paso a paso hasta obtener un valor final o detectar un error semántico.

En otras palabras, el intérprete funge como puente entre la especificación teórica y el comportamiento observable del lenguaje: toma las expresiones del usuario, las transforma a la sintaxis abstracta sin azúcar sintáctica (ASV), y posteriormente dirige el proceso de evaluación conforme a las reglas formales previamente establecidas.

El intérprete opera manteniendo un ambiente de ejecución (\(\varepsilon\)) y evaluando cada expresión de acuerdo con la relación de transición definida en el sistema de semántica estructural. Cada paso de evaluación corresponde directamente a una instancia de alguna de nuestras reglas inferenciales, lo cual garantiza que la implementación permanezca fiel al modelo teórico.

De manera general, nuestro intérprete debe:

\begin{itemize}
  \item Recibir una expresión en sintaxis concreta y traducirla a su representación en el ASA y posteriormente ASV.
  \item Inicializar un ambiente de ejecución vacío o con valores predefinidos.
  \item Aplicar las reglas de evaluación de manera iterativa (paso a paso), hasta alcanzar un valor final (estado final), una expresión bloqueada, o un error.
  \item Gestionar ambientes y cierres (\textit{closures}) para implementar alcance léxico y funciones como valores de primera clase.
  \item Reportar resultados o errores de evaluación al usuario de forma clara.
\end{itemize}

Es importante destacar que, dado que nuestra semántica es de paso pequeño (\textit{small-step}), el intérprete refleja explícitamente la evolución del programa a través de múltiples transiciones, lo cual facilita tanto la verificación formal como la depuración y el entendimiento del proceso de ejecución.

Con este componente, obtenemos un sistema completo: comenzamos con la especificación formal, definimos su semántica, y finalmente construimos un ejecutor funcional que sigue rigurosamente dichas reglas. Esto garantiza que el lenguaje\minilisp no solo está formalmente fundamentado, sino que también es operacionalmente realizable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Función paso pequeño en\minilisp}

Para nuestro lenguaje definimos la función de evaluación como sigue:

\begin{lstlisting}[style=haskellstyle, caption={Tipo de dato \texttt{ASV} (Estados Finales) y \texttt{ENV} (ambiente de evaluación)}]
module ASV where

import AST

{--
Definimos la representacion del ambiente de ejecucion.
Un ambiente es una lista de pares (id, valor).
--}
type Env = [(String, ASV)]

{-- ASA Values --}
data ASV
  = VarV String
  | NumV Int
  | BoolV Bool
  | NiV
  | AddV ASV ASV
  | SubV ASV ASV
  | MulV ASV ASV
  | DiV ASV ASV
  | SqrtV ASV
  | NotV ASV
  | EqualV ASV ASV
  | LessV ASV ASV
  | GreaterV ASV ASV
  | DiffV ASV ASV
  | LeqV ASV ASV
  | GeqV ASV ASV
  | PairV ASV ASV
  | FstV ASV
  | SndV ASV
  | IfV ASV ASV ASV
  | FunV String ASV
  | AppV ASV ASV
  | ConV ASV ASV
  | HeadV ASV
  | TailV ASV
  | Closure String ASV Env
  deriving (Show, Eq)
\end{lstlisting}

Definimos tanto los estados finales como un nuevo tipo llamado Env, que representa el ambiente de evaluación.
Este ambiente no es más que una emulación de la pila donde guardamos los ambientes como pares ((id, valor) como
si de \texttt{[}"\texttt{id}" $\to$ \textit{value}\texttt{]}), donde cada identificador está asociado con el
valor que tiene en ese momento de la ejecución.\\


Ahora definimos la función principal \texttt{eval}, para el intérprete del lenguaje:
  
\begin{lstlisting}[style=haskellstyle, caption={Estados Finales}]
module Interprete where

import ASV

{-- Funcion principal del interprete --}
{--
Evaluamos una expresion paso a paso utilizando la funcion 'pasito' hasta llegar a algun valor canonico.
--}
eval :: ASV -> Env -> ASV
eval asv env
  | isValue asv = asv
  | otherwise =
    let (asv', env') = pasito asv env
     in eval asv' env'

{-- Funcion que determina si una expresion es valor canonico --}
isValue :: ASV -> Bool
isValue (NumV _) = True
isValue (BoolV _) = True
isValue (Closure _ _ _) = True
isValue (PairV f s) = isValue f && isValue s
isValue (ConV f s) = isValue f && isValue s
isValue (NiV) = True
isValue _ = False
\end{lstlisting}

La función \texttt{eval} recibe un estado final con el ambiente de inicio el cuál es vacío al comienzo de la evaluación y devuelve un \texttt{ASV} que se al terminar será un valor canónico.

\noindent
Utilizamos guardas con los que describimos que hacer. Si la expresión ya es un valor canónico (según \texttt{isValue}), no hay nada que evaluar y devolvemos el valor tal cual. En otro caso procedemos a evaluar la expresión paso a paso.

\noindent
Con la función auxiliar \texttt{isValue} utilizando la casa de patrones definimos cuales estados son valores canónicos que ya establecimos y, en caso de serlo, devolvemos \texttt{True}, en otro caso no es canónico y devolvemos \texttt{False}.\\

Modelamos las reglas de evaluación con paso pequeño de\minilisp{-0.2cm} con la función \texttt{pasito}. Esta función \texttt{pasito} recibe el estado final con su ambiente a evaluar y regresa la configuración resultante:

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{pasito} para valores, casos base}]
{--  Funcion pasito que implementa la semantica operacional estructural del lenguaje --}
{--
'Avanza' un solo paso en la evaluacion de una expresion, devolviendo el resultado y el ambiente actualizado.
--}
pasito :: ASV -> Env -> (ASV, Env)
--Valores
pasito (VarV i) env  = (mirarriba i env, env)
pasito (NumV n) env  = (NumV n, env)
pasito (BoolV b) env = (BoolV b, env)
pasito (NiV) env     = (NiV, env)


{-- Funcion mirarriba (lookup) para la busqueda de variables en el ambiente --}
mirarriba :: String -> Env -> ASV
mirarriba i [] = error ("Var '" ++ i ++ "' no definida")
mirarriba i ((j, v):e)
  | i == j = v
  | otherwise = mirarriba i e
\end{lstlisting}

Como se puede ver, \texttt{pasito} utiliza la casa de patrones de acuerdo con las reglas que establecimos previamente. \texttt{NumV n}, \texttt{BoolV b} y \texttt{NiV} solo devuelven la misma expresión con el mismo ambiente recibido.\\

Tenemos la mención especial de que para las variables \texttt{VarV} utilizamos \texttt{lookup}, que en nuestra implementación, con un arrebato increíble de originalidad lo nombramos como \texttt{mirarriba}; para buscar las varibales en el ambiente dado. La función implementa la búsqueda de una variable en el ambiente, toma el nombre de una variable y un ambiente \texttt{Env} y devuelve el \texttt{ASV} asociado.

\noindent
Si el ambiente es vacío o llegamos al final de este y no encontramos la variable, lanzamos un error con un mensaje indicando que la variable no está definida, deteniedno la ejecución de todo el intérprete. En el caso recursivo, comprobamos que el identificador en el ambiente sea el mismo que el ambiente que se está buscando, en caso de que coincidan devolvemos el valor v asociado ya que hemos encontrado la variable. En otro caso, si no coinciden, continuamos la búsqueda recursivamente en la cola. Recorremos el ambiente hasta encontrar la variable o agotar la "$pila$".

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{pasito} para operadores}]
pasito :: ASV -> Env -> (ASV, Env)
-- Operadores
pasito (AddV (NumV n) (NumV m)) env = (NumV (n + m), env)
pasito (AddV (NumV n) d) env        = let (d', env') = pasito d env
                                      in (AddV (NumV n) d', env')
pasito (AddV i d) env               = let (i', env') = pasito i env
                                      in (AddV i' d, env')
pasito (SubV (NumV n) (NumV m)) env = (NumV (n - m), env)
pasito (SubV (NumV n) d) env        = let (d', env') = pasito d env
                                      in (SubV (NumV n) d', env')
pasito (SubV i d) env               = let (i', env') = pasito i env
                                      in (SubV i' d, env')
pasito (MulV (NumV n) (NumV m)) env = (NumV (n * m), env)
pasito (MulV (NumV n) d) env        = let (d', env') = pasito d env
                                      in (MulV (NumV n) d', env')
pasito (MulV i d) env               = let (i', env') = pasito i env
                                      in (MulV i' d, env')
pasito (DiV (NumV n) (NumV m)) env
  | m == 0 = error ("No se puede dividir entre 0")
  | otherwise = (NumV (div n m), env)
pasito (DiV (NumV n) d) env = let (d', env') = pasito d env
                               in (DiV (NumV n) d', env')
pasito (DiV i d) env        = let (i', env') = pasito i env
                               in (DiV i' d, env')
pasito (SqrtV (NumV n)) env
  | n < 0 = error ("No se puede obtener la raiz de un numero negativo")
  | otherwise = (NumV (integerSquareRoot n), env)
pasito (SqrtV n) env         = let (n', env') = pasito n env
                               in (SqrtV n', env')

{-- Funcion auxiliar para SqrtV para calcular la raiz cuadrada de un numero entero --}
integerSquareRoot :: Int -> Int
integerSquareRoot n = floor (sqrt (fromIntegral n :: Double))
\end{lstlisting}

Para las siguientes reglas de evaluación definiremos primero la tercer regla de cada expresión donde los arguementos de estas ya son valores, ya que al usar \textit{pattern matching} debemos implementarlo de este modo pues de otra forma caeríamos siempre en la primer regla donde solo evaluamos un argumento, lo que derivaría en un bucle infinito. Así, la regla para los operadores utiliza las reglas donde ambos argumentos son ya números para terminar la evaluación, donde usamos los operadores del lenguaje anfitrión respectivos a la expresión.

\noindent
Los casos especiales son para la división y la raíz cuadrada, donde, una vez llegamos a un \texttt{NumV}, comprobamos que no sea cero, para la división, o que no sea negativo, para la raíz. En el caso de \texttt{SqrtV}, una vez comprobamos que el número es válido, nos apoyamos de la función auxiliar \texttt{integerSquareRoot} que convierte el entero a \texttt{Double}, calcula la raíz cuadrada y la trunca hacia abajo, devolviendo un \texttt{Int}.\\

De manera similar implementamos las reglas para los comparadores:

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{pasito} para comparadores}]
pasito :: ASV -> Env -> (ASV, Env)
--Not
pasito (NotV (BoolV b)) env = (BoolV (not b), env)
pasito (NotV e) env         = let (e', env') = pasito e env
                              in (NotV e', env')
--Comparadores
pasito (EqualV (NumV n) (NumV m)) env   = (BoolV (n == m), env)
pasito (EqualV (NumV n) d) env          = let (d', env') = pasito d env
                                          in (EqualV (NumV n) d', env')
pasito (EqualV i d) env                 = let (i', env') = pasito i env
                                          in (EqualV i' d, env')
pasito (LessV (NumV n) (NumV m)) env    = (BoolV (n < m), env)
pasito (LessV (NumV n) d) env           = let (d', env') = pasito d env
                                          in (LessV (NumV n) d', env')
pasito (LessV i d) env                  = let (i', env') = pasito i env
                                          in (LessV i' d, env')
pasito (GreaterV (NumV n) (NumV m)) env = (BoolV (n > m), env)
pasito (GreaterV (NumV n) d) env        = let (d', env') = pasito d env
                                          in (GreaterV (NumV n) d', env')
pasito (GreaterV i d) env               = let (i', env') = pasito i env
                                          in (GreaterV i' d, env')
pasito (DiffV (NumV n) (NumV m)) env    = (BoolV (n /= m), env)
pasito (DiffV (NumV n) d) env           = let (d', env') = pasito d env
                                          in (DiffV (NumV n) d', env')
pasito (DiffV i d) env                  = let (i', env') = pasito i env
                                          in (DiffV i' d, env')
pasito (LeqV (NumV n) (NumV m)) env     = (BoolV (n <= m), env)
pasito (LeqV (NumV n) d) env            = let (d', env') = pasito d env
                                          in (LeqV (NumV n) d', env')
pasito (LeqV i d) env                   = let (i', env') = pasito i env
                                          in (LeqV i' d, env')
pasito (GeqV (NumV n) (NumV m)) env     = (BoolV (n <= m), env)
pasito (GeqV (NumV n) d) env            = let (d', env') = pasito d env
                                          in (GeqV (NumV n) d', env')
pasito (GeqV i d) env                   = let (i', env') = pasito i env
                                          in (GeqV i' d, env')
\end{lstlisting}

En el caso de \texttt{Not}, una vez que el argumento es \texttt{BoolV} retornamos la negación en Haskell de este \texttt{BoolV} como un nuevo \texttt{BoolV}. De la misma manera como fue con los operadores aritméticos, cuando ambos argumentos ya son números con los cuales comparar, regresamos la comparación como valor booleano\texttt{BoolV} con el resultado evaluado con los operadores de comparación en Haskell.

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{pasito} para comparadores}]
pasito :: ASV -> Env -> (ASV, Env)
--Pares
pasito (PairV f s) env
  | isValue (PairV f s) = (PairV f s, env)
  | isValue f = let (s', env') = pasito s env
                in (PairV f s', env')
  | otherwise = let (f', env') = pasito f env
                in (PairV f' s, env')
pasito (FstV (PairV f s)) env
  | isValue f && isValue s = (f, env)
pasito (FstV p) env = let (p', env') = pasito p env
                      in (FstV p', env')
pasito (SndV (PairV f s)) env
  | isValue f && isValue s = (s, env)
pasito (SndV p) env = let (p', env') = pasito p env
                      in (SndV p', env')
---Cons
pasito (ConV f s) env
  | isValue (ConV f s) = (ConV f s, env)
  | isValue f = let (s', env') = pasito s env
                in (ConV f s', env')
  | otherwise = let (f', env') = pasito f env
                in (ConV f' s, env')
pasito (HeadV (ConV f s)) env
  | isValue f && isValue s = (f, env)
pasito (HeadV p) env =
  let (p', env') = pasito p env
  in (HeadV p', env')
pasito (TailV (ConV f s)) env
  | isValue f && isValue s && not (isConV s) = (s, env)
  | otherwise = let (s', env') = pasito s env
                in (TailV s', env')
pasito (TailV p) env =
  let (p', env') = pasito p env
  in (TailV p', env')

  
{-- Funcion que nos dice si la estructura sigue siendo un ecadenamiento de ConV--}
isConV :: ASV -> Bool
isConV (ConV _ _) = True
isConV _ = False
\end{lstlisting}

Para el caso de \texttt{PairV} y \texttt{ConV}, en ambos, comprobamos que sean valores canónicos y aunque suene redundante, con la función \texttt{isValue}, ambos son valores si y sólo si sus dos argumentos también son valores. En otro caso continuamos evaluando ambas expresiones, primero con el primer argumento hasta llegar a un valor para poder seguir con la evalución del segundo.

\noindent
Para la evaluación de los operadores sobre pares, con \texttt{FstV}, como utilizamos evaluación glotona, debemos llegar a que el par recibido tenga ambas expresiones como valor, para así devolver el primer argumento del par. Lo mismo con \texttt{SndV} que, hasta tener los argumentso $f$ y $s$ como valores, devolvemos $s$, el segundo.\\

Para el caso de \texttt{HeadV} con \texttt{ConV} es análogo a \texttt{FstV} con los pares. Sin embargo, \texttt{TailV} no solo necesita que ambos argumentos ya seal valores, sino que el segundo valor no sea de tipo \texttt{ConV}, pues esto significa que hay más expresiones en el encadenamiento de \texttt{ConV}, por lo que necesitamos seguir con este segundo argumento hasta llegar a un valor canónico dinstinto de \texttt{ConV} -justo como en las reglas de evaluación para esta expresión-.

\noindent
Para lograr esto, no apoyamos en la función \texttt{isConV}, que nos ayuda a determinar que la expresión dada sea otro \texttt{ConV} o si es otro valor canónico.\\

Para las reglas de la condicional \texttt{IfV} su implementación es más sencilla pues basta que, al llegar a un valor \texttt{BoolV} de la condición devolvemos la configuración respectiva: \texttt{(t, env)} en el caso de que la condición es verdad, y \texttt{(e, env)} en otro caso. De otro modo, continuamos evaluando la condición.

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{pasito} para comparadores}]
pasito :: ASV -> Env -> (ASV, Env)
--If
pasito (IfV (BoolV True) t e) env  = (t, env)
pasito (IfV (BoolV False) t e) env = (e, env)
pasito (IfV c t e) env             = let (c', env') = pasito c env
                                     in (IfV c' t e, env')
\end{lstlisting}

Por último tenemos las funciones y \texttt{FunV} las aplicaciones de funciones \texttt{AppV}, que quedan como sigue:

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{pasito} para comparadores}]
pasito :: ASV -> Env -> (ASV, Env)
--Funciones
pasito (FunV p c) env = (Closure p c env, env)
--Aplicacion de funciones
pasito (AppV (Closure p c env') a) env
  | isValue a = (c, (p, a):env')
  | otherwise =
    let (a', env'') = pasito a env
    in (AppV (Closure p c env') a', env'')  
pasito (AppV f a) env = let (f', env') = pasito f env
                        in (AppV f' a, env')
\end{lstlisting}

La evaluación de las funciones es simple, la función \texttt{FunV} se convierte en una cerradura con el mismo ambiente de la configuración. Para \texttt{AppV}, siguiendo las reglas de evaluación para esta expresión: si se tiene una cerradura con un argumento a aplicar, comprobamos que este argumento sea ya un valor canónico, de ser así, retornamos la configuración con la aplicación extendiendo el ambiente. En otro caso continuamos evaluacndo el argumento. De no ser una cerradura, entonces evaluamos esta función.\\

Así, terminamos la evaluación glotona con alcance estático usando paso pequeño con la función \texttt{pasito} en nuestro intérprete.

\bigskip

Sin embargo, esta implementación no nos sirve para la aplicación de funciones derivada de \texttt{LetRec}, pues veamos el resultado de evaluar \texttt{LetRec}:

\begin{minted}[fontsize=\small, bgcolor=black!5, frame=single]{text}
[MiniLisp]> (letrec (sum (lambda (n) (if0 n 0 (+ n (sum (- n 1)))))) (sum 3))
[Error]: Var 'Z' no definida
CallStack (from HasCallStack):
  error, called at ./Interprete.hs:154:18 in main:Interprete
\end{minted}

Y es debido a que, como se menciono en en el capítulo de \textbf{Azúcar Sintáctica}, necesitamos definir un \textit{Combinador} para darle recursión. Más concretamente, usamos el combinador \textbf{Z}:

\[
(\lambda f.((\lambda x.(f (\lambda v.((x x) v)))) (\lambda x.(f (\lambda v.((x x) v))))))
\]

\begin{quote}
  \textit{creo se puede mejorar la explicacion anterior}
\end{quote}

Y este combinador debemos agregarlo al ambiente de evaluación para que en el interpretre lo utilice, y asu vez, el ambiente debe estar evaluado:

\[
\texttt{[Z} \to (\lambda f.((\lambda x.(f (\lambda v.((x x) v)))) (\lambda x.(f (\lambda v.((x x) v)))))) \texttt{]}
\]

No obstante, esto también presenta un error a la hora de ser evaluado:

\begin{minted}[fontsize=\small, bgcolor=black!5, frame=single]{text}
[MiniLisp]> (letrec (sum (lambda (n) (if0 n 0 (+ n (sum (- n 1)))))) (sum 3))
[Error]: Var 'v' no definida
CallStack (from HasCallStack):
  error, called at ./Interprete.hs:154:18 in main:Interprete
\end{minted}

Este error ocurre porque el combinador \textbf{Z}, bajo un esquema de evaluación glotona, intenta evaluar inmediatamente el argumento que representa la función recursiva. En términos operacionales, la versión clásica del combinador de punto fijo asume evaluación perezosa (lazy evaluation): el argumento debe permanecer sin evaluar hasta que sea estrictamente necesario. En nuestro caso, la evaluación glotona fuerza la aplicación prematura de la función a sí misma, lo que conduce a buscar variables aún no ligadas en el ambiente, provocando fallos como la variable \texttt{v} no definida.

En otras palabras, la raíz del problema es que:

\begin{itemize}
  \item el combinador \textbf{Z} está diseñado para lenguajes con evaluación perezosa,
  \item nuestro intérprete aplica evaluación glotona,
  \item y como consecuencia, la expansión recursiva ocurre antes de que el ambiente esté correctamente extendido.
\end{itemize}

Para soportar recursión en un lenguaje con evaluación estricta necesitamos, entonces, adaptar la construcción del combinador o modificar la semántica para permitir que las referencias recursivas se establezcan antes de evaluarse efectivamente. En la siguiente sección abordamos precisamente esta extensión.

