\chapter{Semántica Operacional}

Una vez hemos establecido nuestro sintaxis del lenguaje en núcleos, lo siguiente a realizar darle el significado a estos programas. Para ello recurrimos a la semántica operacional, un enfoque que describe la dinámica de ejecución de los programas mediante un conjunto de reglas de inferencia.

\begin{quote}
  \textit{Desarrollar la introducción y explicación de la formalización de la semántica y semántica operacional.}
\end{quote}

La semántica operacional...
\begin{quote}
  \textit{Continuar con la definicion de semantica operacional .}
\end{quote}

%se formula como un sistema de transición, donde el comportamiento de un programa se entiende como una sucesión de pasos que transforman configuraciones intermedias hasta llegar a un resultado final. Este enfoque no solo captura el proceso de evaluación de manera formal y precisa, sino que además mantiene una correspondencia directa entre la estructura sintáctica del lenguaje y su dinámica de ejecución. Facilita la implementación de intérpretes, ya que las reglas pueden traducirse de manera casi inmediata en algoritmos. Proporciona un marco para el razonamiento formal sobre las propiedades del lenguaje (corrección, terminación, equivalencias, etc.).

Existen dos estilos principales:

Semantica Natural conocido como paso grande (Big-step)
\begin{quote}
  \textit{Definir brevemente lo que es paso pequeño y quien lo definio.}
\end{quote}

Semantica Estructural conocida como paso pequeño (Small-step)
\begin{quote}
  \textit{Definir brevemente lo que es paso grande y quien lo definio.}
\end{quote}

Para nuestro lenguaje nos enfocaremos en este último.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Semántica Estructural (Paso pequeño)}
Se le conoce también como semántica de paso pequeño o de transición describe paso a paso la ejecución mostrando los cómputos que genera en cada paso individualmente.

\begin{quote}
  \textit{Aqui ya describimos toda la historia de paso pequeño, qué significa paso pequeño y por que debemos impleemntarlo}
\end{quote}

%Para modelar esta noción, definimos la siguiente relación:
%\begin{center}$e_1 \rightarrow e_2$}end{center}
%que a diferencia de la semántica natural, no relaciona necesariamente expresiones con su valor final, si no que relaciona expresiones con expresiones (pudiendo ser estados finales). Se lee como en un paso e1 se reduce a e2. La definición de reglas en este tipo de semántica, es más complicada pues se tienen que considerar pasos intermedios que en ocasiones pasan desapercibidos al ejecutar o analizar un programa. antes de definir las reglas debemos definir lo que es un sistema de transicion.

\subsection{Sistema de transición}
\begin{quote}
  \textit{Dar la definicion y explicacion de un sistema de transision y como la aplicaremos a nustro proyecto. Tambien mencionamos y describimos los estados finales pero solo eso, no los definimos para el lenguaje}
\end{quote}

%Para modelar formalmente la ejecución, definimos un **sistema de transición**, el cual especifica cómo se produce la evolución de los estados durante la evaluación. **Definición (Sistema de transición):** Un sistema de transición es una tupla (E,$\delta$,I,F) donde: $E$: conjunto (posiblemente infinito) de estados. $\delta \subseteq E \times E$: relación de transición, que indica cómo un estado puede evolucionar a otro. $I\subseteq E$: conjunto de estados iniciales, desde los cuales comienza la ejecución. $F \subseteq E$: conjunto de estados finales, que representan los puntos de término de la ejecución.
%En este marco, el comportamiento de un programa se formaliza como una secuencia de transiciones: $e_0 \;\to\; e_1 \;\to\; e_2 \;\to\; \dots \;\to\; e_f$ Donde $e_0 \in I$, $e_f \in F$ y cada paso $(e_i, e_{i+1}) \in \delta$ está justificado por una regla de inferencia. $\#\#$ Sistema de transición  *small-step* para Iris El sistema de transición de paso pequeño para el lenguaje se define como la tupla $(E, \to, I, F)$, donde: $E = \{\, e \mid e \in ASA \,\}$ es el conjunto de expresiones bien formadas en sintaxis abstracta. $\to \;\subseteq\; E \times E$ es la relación de reducción (small-step) que relaciona una expresión con otra expresión (intermedia o final). Usaremos la notación $e \to e'$ para indicar una reducción de un paso de $e$ a $e'$. $I = E$, es decir, cualquier expresión bien formada puede considerarse un estado inicial. $F$ es el conjunto de estados finales (valores canónicos) dado por: $F \;=\; \{\, Num(n) \mid n \in \mathbb{Z} \,\} \;\cup\; \{\, Boolean(b) \mid b \in \{True,False\} \,\} \;\cup\; \{\, Pair(f,s) \mid f,s \in F \,\} \;\cup\; \{\, Closure(l,\varepsilon) \mid l \text{ es una función y } \varepsilon \text{ es un ambiente léxico} \,\} \;\cup\; \{\, Error \mid \text{la ejecución es interrumpida} \,\}.$ En este sistema, la evaluación se modela como una secuencia finita o infinita de reducciones de un solo paso: $e_0 \;\to\; e_1 \;\to\; e_2 \;\to\; \cdots$ donde $ e_0 \in I$. Una ejecución ha terminado normalmente cuando se alcanza $e_k \in F$. Si en algún paso se llega a la expresión especial $Error$, la ejecución queda interrumpida y se considera una terminación anómala.

\begin{quote}
  \textit{Explicar lo que es la cerradura }
\end{quote}

\subsection{Estados Finales en\minilisp}

Definimos los estados finales para el lenguaje\minilisp{-0.2cm}:

\begin{align*}
  F = &\{\, Num_{V}(n) \mid n \in \Z\,\}\: \cup \:\{\, Boolean_{V}(b) \mid b \in \{True,False\}\,\}\: \cup \:\{\, Pair_{V}(f,s) \mid f,s\in F\,\}\: \cup \\
  &\{\, Cons_{V}(h,t) \mid h,t\in C\,\}\: \cup \:\{\, Nil_{V} \mid \text{ es la lista vacía}\}\: \cup \\
  &\{\, Closure (f,\varepsilon) \mid f \text{ es una función y } \varepsilon\text{ es un ambiente léxico}\}
\end{align*}

Intuitivamente implementamos los estados finales en nuestro lenguaje como un tipo de dato en Haskell:

\begin{lstlisting}[style=haskellstyle, caption={Tipo de dato ASV, representan los estados finales}]
module ASV where

-- ASA Values
data ASV
  = VarV String
  | NumV Int
  | BoolV Bool
  | NiV
  | PairV ASV ASV
  | ConV ASV ASV
  | Closure String ASV [(String, ASV)]
  deriving (Show, Eq)
\end{lstlisting}

El tipo de dato \texttt{ASV} serán con el que modelaremos los estados finales del lenguaje. Sin embargo, en nuestra implementación, es necesario agregar las demás estructuras que trabajan con estos estados finales -como lo son los operadores aritméticos o las operaciones sobre pares o listas- ya que \texttt{ASV} sigue modelando una estructura de tipo árbol la cual sigue el mismo principio que las estructuras \texttt{ASA}:

\begin{center}
  \textit{Una expresión es \texttt{ASV} si y solo si sus hijos también son \texttt{ASV}.}
\end{center}

Por lo que debemos hacer que nuestros Para diferenciar entre los verdaderos estados finales y las demás estructuras de tipo \texttt{ASV} será que nos referimos a los finales como \textit{\textbf{valores canónicos}}.\footnote{Más adelante enfatizaremos en como los diferenciamos entre Valores \texttt{ASV} y expresiones \texttt{ASV} en Haskell.}
Lo que nos queda en la nueva definición del tipo de dato \texttt{ASV}:

\begin{lstlisting}[style=haskellstyle, caption={Tipo de dato ASV completo}]
-- ASA Values
data ASV
  = VarV String
  | NumV Int
  | BoolV Bool
  | NiV
  | AddV ASV ASV
  | SubV ASV ASV
  | MulV ASV ASV
  | DiV ASV ASV
  | SqrtV ASV
  | NotV ASV
  | EqualV ASV ASV
  | LessV ASV ASV
  | GreaterV ASV ASV
  | DiffV ASV ASV
  | LeqV ASV ASV
  | GeqV ASV ASV
  | PairV ASV ASV
  | FstV ASV
  | SndV ASV
  | IfV ASV ASV ASV
  | FunV String ASV
  | AppV ASV ASV
  | ConV ASV ASV
  | HeadV ASV
  | TailV ASV
  | Closure String ASV [(String, ASV)]
  deriving (Show, Eq)
\end{lstlisting}

Ya que hemos definido el tipo de dato \texttt{ASV} veamos como convertimos nuestras estructuras \texttt{AST} a estados finales \texttt{ASV}:

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{toFinalState} que transforma los núcleos \texttt{AST} a estados finales \texttt{ASV}}]
  {-- Convertimos los AST a estados finales ASV --}
  toFinalState :: AST -> ASV
  toFinalState (VarC x) = VarV x
  toFinalState (NumC n) = NumV n
  toFinalState (BoolC b) = BoolV b
  toFinalState (AddC i d) = AddV (toFinalState i) (toFinalState d)
  toFinalState (SubC i d) = SubV (toFinalState i) (toFinalState d)
  toFinalState (MulC i d) = MulV (toFinalState i) (toFinalState d)
  toFinalState (DivC i d) = DiV (toFinalState i) (toFinalState d)
  toFinalState (SqrtC n) = SqrtV (toFinalState n)
  toFinalState (NotC x) = NotV (toFinalState x)
  toFinalState (EqualC i d) = EqualV (toFinalState i) (toFinalState d)
  toFinalState (LessC i d) = LessV (toFinalState i) (toFinalState d)
  toFinalState (GreaterC i d) = GreaterV (toFinalState i) (toFinalState d)
  toFinalState (DiffC i d) = DiffV (toFinalState i) (toFinalState d)
  toFinalState (LeqC i d) = LeqV (toFinalState i) (toFinalState d)
  toFinalState (GeqC i d) = GeqV (toFinalState i) (toFinalState d)
  toFinalState (PairC f s) = PairV (toFinalState f) (toFinalState s)
  toFinalState (FstC p) = FstV (toFinalState p)
  toFinalState (SndC p) = SndV (toFinalState p)
  toFinalState (ConS f s) = ConV (toFinalState f) (toFinalState s)
  toFinalState (HeadC p) = HeadV (toFinalState p)
  toFinalState (TailC p) = TailV (toFinalState p)
  toFinalState (IfC c t e) = IfV (toFinalState c) (toFinalState t) (toFinalState e)
  toFinalState (FunC p b) = FunV p (toFinalState b)
  toFinalState (AppC f a) = AppV (toFinalState f) (toFinalState a)
  toFinalState NiL = NiV
\end{lstlisting}

La función \texttt{toFinalState} transforma cada estructura del núcleo AST en su equivalente ASV. Aunque a primera vista parezca una simple correspondencia entre constructores, su propósito es fundamental: garantizar que todas las expresiones que se evalúan dentro del intérprete sean expresadas en términos de ASV, permitiendo así que la semántica del lenguaje opere únicamente sobre estructuras homogéneas y compatibles con los valores finales del lenguaje.

\subsection{Reglas de evaluación}

\begin{quote}
  \textit{Dar una introduccion de que son las reglas de evaluacion y por que son necesarias, ademas completar con la explicacion de las reglas de evaluacion. Hablar de los ambientes}
\end{quote}

\begin{itemize}
\item Expresiones atómicas:
  \begin{itemize}
  \item VarV(i):
    \[
    \frac{lookup\ i\ \varepsilon = v}{\langle VarV(i), \varepsilon \rangle \to \langle v, \varepsilon \rangle}
    \]
    \[
    \frac{lookup\ i\ \varepsilon \ \text{no está definido}}{\langle Varv(i), \varepsilon \rangle \to \text{Error en la ejecución de la evaluación}}
    \]

    \begin{quote}
      \textit{Aqui se puede poner la explicacion breve de lo que hace lookup}
    \end{quote}
    
  \item NumV(n):
    \[
    \frac{}{\langle NumV(n), \varepsilon \rangle \to \langle NumV(n), \varepsilon \rangle}
    \]
    
  \item BoolV(b):
    \[
    \frac{}{\langle BoolV(b), \varepsilon \rangle \to \langle BoolV(b), \varepsilon \rangle}
    \]
  \item NiV:
    \[
    \frac{}{\langle NivV, \varepsilon \rangle \to \langle NiV, \varepsilon \rangle}
    \]
  \end{itemize}
  
\item AddV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle AddV(i,d), \varepsilon \rangle \to \langle AddV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle AddV(NumV(n),d), \varepsilon \rangle \to \langle Add(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle AddV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n +_{\Z} m), \varepsilon \rangle}
  \]
  
\item SubV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle SubV(i,d), \varepsilon \rangle \to \langle SubV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle SubV(NumV(n),d), \varepsilon \rangle \to \langle SubV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle SubV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n -_{\Z} m), \varepsilon \rangle}
  \]
 
\item MulV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle MulV(i,d), \varepsilon \rangle \to \langle MulV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle MulV(NumV(n),d), \varepsilon \rangle \to \langle MulV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle MulV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n *_{\Z} m), \varepsilon \rangle}
  \]
  
\item DiV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle DiV(i,d), \varepsilon \rangle \to \langle DiV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle DiV(NumV(n),d), \varepsilon \rangle \to \langle DiV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle DiV(NumV(n),NumV(0)), \varepsilon \to \text{Error en la ejecución de la evaluación}}
  \]
  \[
  \frac{}{ \langle DiV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle NumV(n\ /_{\Z}\ m), \varepsilon \rangle} \quad (m \neq 0)
  \]
  
\item SqrtV(n):
  \[
  \frac{\langle n, \varepsilon \rangle \to \langle n', \varepsilon \rangle}{\langle SqrtV(n), \varepsilon \rangle \to \langle SqrtV(n'), \varepsilon \rangle}
  \]
  \[
  \frac{n < 0}{\langle SqrtV(NumV(n)), \varepsilon \to \text{Error en la ejecución de la evaluación}}
  \]
  \[
  \frac{}{\langle SqrtV(NumV(n)), \varepsilon \rangle \to \langle NumV(\sqrt{n}_{\N}), \varepsilon \rangle}  \quad (n \geq 0)
  \]
  
\item NotV(b):
  \[
  \frac{\langle b, \varepsilon \rangle \to \langle n', \varepsilon \rangle}{\langle NotV(b), \varepsilon \rangle \to \langle NotV(b'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle NotV(BoolV(b)), \varepsilon \rangle \to \langle BoolV(\neg_{\P}b) \varepsilon \rangle}
  \]
  
\item EqualV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle EqualV(i,d), \varepsilon \rangle \to \langle EqualV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle EqualV(NumV(n),d), \varepsilon \rangle \to \langle EqualV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle EqualV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n =_{\Z} m), \varepsilon \rangle}
  \]

\item LessV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle LessV(i,d), \varepsilon \rangle \to \langle LessV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle LessV(NumV(n),d), \varepsilon \rangle \to \langle LessV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle LessV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n <_{\Z} m), \varepsilon \rangle}
  \]
  
\item GreaterV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle GreaterV(i,d), \varepsilon \rangle \to \langle GreaterV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle GreaterV(NumV(n),d), \varepsilon \rangle \to \langle GreaterV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle GreaterV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n >_{\Z} m), \varepsilon \rangle}
  \]
  
\item DiffV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle DiffV(i,d), \varepsilon \rangle \to \langle DiffV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle DiffV(NumV(n),d), \varepsilon \rangle \to \langle DiffV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle DiffV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n \neq_{\Z} m), \varepsilon \rangle}
  \]
  
\item LeqV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle LeqV(i,d), \varepsilon \rangle \to \langle LeqV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle LeqV(NumV(n),d), \varepsilon \rangle \to \langle LeqV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle LeqV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n \leq_{\Z} m), \varepsilon \rangle}
  \]
  
\item GeqV(i,d)
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle GeqV(i,d), \varepsilon \rangle \to \langle GeqV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{\langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle GeqV(NumV(n),d), \varepsilon \rangle \to \langle GeqV(NumV(n),d'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle GeqV(NumV(n),NumV(m)), \varepsilon \rangle \to \langle BoolV(n \geq_{\Z} m), \varepsilon \rangle}
  \]
\end{itemize}

Como se puede ver en las reglas para los comparadores, la regla final cuando ambas expresiones del comparador son el resultado deriva en

\begin{itemize}  
\item PairV(f,s):
  \[
  \frac{\langle f, \varepsilon \rangle \to \langle f', \varepsilon \rangle}{\langle PairV(f,s), \varepsilon \rangle \to \langle PairV(f',s), \varepsilon \rangle}
  \]
  \[
  \frac{\langle s, \varepsilon \rangle \to \langle s', \varepsilon \rangle}{\langle PairV(v_f,s), \varepsilon \rangle \to \langle PairV(v_f,s'), \varepsilon \rangle}
  \]
  \[
  \frac{v_f, v_s \text{ son valores canónicos}}{\langle PairV(v_f,v_s), \varepsilon \rangle \to \langle PairV(v_f,v_s), \varepsilon \rangle}
  \]
  
\item FstV(p):
  \[
  \frac{\langle p, \varepsilon \rangle \to \langle p', \varepsilon \rangle}{\langle FstV(p), \varepsilon \rangle \to \langle FstV(p'), \varepsilon \rangle}
  \]
  \[
  \frac{v_1, v_2 \text{ son valores canónicos}}{\langle FstV(PairV(v_1,v_2)), \varepsilon \rangle \to \langle v_1, \varepsilon \rangle}
  \]
  
\item SndV(p):
  \[
  \frac{\langle p, \varepsilon \rangle \to \langle p', \varepsilon \rangle}{\langle SndV(p), \varepsilon \rangle \to \langle SndV(p'), \varepsilon \rangle}
  \]
  \[
  \frac{v_1, v_2 \text{ son valores canónicos}}{\langle SndV(PairV(v_1,v_2)), \varepsilon \rangle \to \langle v_2, \varepsilon \rangle}
  \]
  
\item IfV(c,t,e), IfV solo evalúa la condicional hasta llegar a un \texttt{BoolV} mas no evalúa el \textbf{then} o \textbf{else} dependiendo del resultado de la condición, solo se encarga de retornar alguno de los dos dependiendo del caso:
  \[
  \frac{\langle c, \varepsilon \rangle \to \langle c', \varepsilon \rangle}{\langle IfV(c,t,e), \varepsilon \rangle \to \langle IfV(c',t,e), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle IfV(BoolV(\#t),t,e), \varepsilon \rangle \to \langle t, \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle IfV(BoolV(\#f),t,e), \varepsilon \rangle \to \langle e, \varepsilon \rangle}
  \]
  
\item ConV(i,d):
  \[
  \frac{\langle i, \varepsilon \rangle \to \langle i', \varepsilon \rangle}{\langle ConV(i,d), \varepsilon \rangle \to \langle ConV(i',d), \varepsilon \rangle}
  \]
  \[
  \frac{v_i \text{ es valor canónico} \; \langle d, \varepsilon \rangle \to \langle d', \varepsilon \rangle}{\langle ConV(v_i,d), \varepsilon \rangle \to \langle ConV(v_i,d'), \varepsilon \rangle}
  \]
  \[
  \frac{v_i, v_d \text{ son valores canónicos}}{\langle ConV(v_i,v_d), \varepsilon \rangle \to \langle ConV(v_i,v_d), \varepsilon \rangle}
  \]
  
\item HeadV(l):
  \[
  \frac{\langle p, \varepsilon \rangle \to \langle p', \varepsilon \rangle}{\langle HeadV(l), \varepsilon \rangle \to \langle HeadV(l'), \varepsilon \rangle}
  \]
  \[
  \frac{}{\langle HeadV(ConV(v_i,v_d)), \varepsilon \rangle \to \langle v_i, \varepsilon \rangle}
  \]
  
\item TailV(l);
  \[
  \frac{\langle l, \varepsilon \rangle \to \langle l', \varepsilon \rangle}{\langle TailV(l), \varepsilon \rangle \to \langle TailV(l'), \varepsilon \rangle}
  \]
  \[
  \frac{v_d \text{ es valor pero } v_d = ConV(i,d) \;\; v_d \to v_d'}{\langle TailV(ConV(v_i,v_d)), \varepsilon \rangle \to \langle TailV(v_i,v_d'), \varepsilon \rangle}
  \]
  \[
  \frac{v_d \text{ es valor pero} v_d \neq ConV(i,d)}{\langle TailV(ConV(v_i,v_d)), \varepsilon \rangle \to \langle v_d, \varepsilon \rangle}
  \]
  
\item FunV(p,c):
  \[
  \frac{}{\langle FunV(p,c), \varepsilon \rangle \to \langle Closure(FunV(p,c), \varepsilon), \varepsilon \rangle}
  \]
  
\item AppV(f,a):
  \[
  \frac{\langle f, \varepsilon \rangle \to \langle f', \varepsilon \rangle}{\langle AppV(f,a), \varepsilon \rangle \to \langle AppV(f',a), \varepsilon \rangle}
  \]
  \[
  \frac{\langle a, \varepsilon \rangle \to \langle a', \varepsilon \rangle}{\langle AppV(Closure(FunV(p,c), \varepsilon'),a), \varepsilon \rangle \to \langle AppV(Closure(FunV(p,c), \varepsilon'),a'), \varepsilon \rangle}
  \]
  \[
  \frac{\^{a} \text{ es un valor canónico}}{\langle AppV(Closure(FunV(p,c), \varepsilon'), \^{a}), \varepsilon \rangle \to \langle c, \varepsilon'[p \leftarrow \^{a}] \rangle}
  \]
\end{itemize}

\begin{quote}
  \textit{Puede que sea buena idea dar un cierre a esto antes de entrar en Haskell}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Intérprete para\minilisp}

Una vez definimos formalmente lo que será la \textbf{\textit{Semántica Operacional Estrcutural}} para nuestro lenguaje podemos programar el interprete del mismo que será el encargado de aplica la evaluación al programa del usuario, más precisamente a las expreciones \texttt{ASV} que ya han depurado el programa original.

\begin{quote}
  \textit{creo podemos extendernos mas aqui}
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Función paso pequeño en\minilisp}

\begin{lstlisting}[style=haskellstyle, caption={}]

\end{lstlisting}
