\chapter{Azúcar Sintáctica}
El término \textit{azúcar sintáctica} \textit{(syntactic sugar)} fue introducido por Peter J.Landin en 1964. La azúcar sintáctica consiste en construcciones del lenguaje que pueden ser sistemáticamente traducidas a formas más básicas sin alterar la semántica del programa. Es decir, no añaden nuevas capacidades expresivas, sino que facilitan la escritura o lectura del código.

Landin fue un pionero de la teoría de lenguajes de programación, utilizó el término para describir aquellas construcciones que, aunque convenientes para el programador, pueden eliminarse mediante una transformación mecánica sin modificar el significado del programa.

\begin{quote}
  Landin uso este termino por primera vez en su trabajo sobre la correspondencia entre programación y cálculo lambda, específicamente en el artículo \textit{"The Next 700 Programming Languages"}~\cite{landin}, aunque la idea aparece en escritos de 1964.
\end{quote}

Continunado con nuestro proyecto. Una vez que hemos elimindo todos los elementos superficilaes y auxiliares de la sintaxis concreta y léxica para quedarnos únicamente con la representación mínima y estructural del programa, es decir, el \textbf{Arbol de Sintaxis Abstracta} (ASA) logramos capturar la estructura esencial del programa. 
Pasamos a la siguiente fase, reducir aún más estos \textbf{ASA} porque a pesar de ya haber eliminado los elementos superficiales de la Sintaxis Concreta, hay expresiones redundantes o que pueden representarse como otras, hacer esto nos reduce en mayor medida las reglas que debemos implementar al momento de la evaluación, en nuestra implementación pasamos de ASA (con azúcar sintáctica) a AST (sin azúcar sintáctica).

Para explicar lo anterior con mas detalle tomaremos un ejemplo:
\[
\texttt{(if0 (+ 8 -8) 0 -1)} \Rightarrow \texttt{(if (= (+ 8 -8) 0) 0 -1)}
\]
\texttt{if0} es análogo a if con la comprobación de que el resultado sea igual a cero, pero con \texttt{if0} el usuario se ahorra hacer cada vez esa comprobación de igualdad, pero esto sigue siendo azúcar para nuestro intérprete.

Estas expresiones \textbf{ASA} sin azúcar sintáctica pertenecen al conjunto que denominamos como \textit{núcleo}, o \textit{core}.

\begin{tcolorbox} [title=\textbf{Corrección 11: Notación $\Rightarrow$}, colframe=red!75!black, colback=red!5!white]

La notación $\Rightarrow$ utilizada en este capítulo no debe confundirse con la empleada en el 
Capítulo 3. En la sección 3, la flecha $\Rightarrow$ la cual ya fue explicada en su respectiva corrección (9).

En cambio, en el presente capítulo la notación $\Rightarrow$ sí representa una \textbf{transformación 
sintáctica real}: la desugarización del ASA (con azúcar sintáctica) hacia un AST más básico 
y uniforme. Aquí la flecha indica una operación semánticamente significativa y definida de 
manera recursiva en nuestra implementación.

Para evitar confusiones, aclaramos que ambos usos corresponden a procesos distintos: 
(1) la construcción del ASA desde la sintaxis concreta, y (2) la eliminación de azúcar 
sintáctica mediante reglas de desugarización.
\end{tcolorbox}

%%%%% 4.1 Sintaxis Abstracta sin azúcar %%%% 
\section{Sintaxis Abstracta sin azúcar en\minilisp}

Necesitamos definir una función que realice el procedimiento e desazucarar los \textbf{ASA} en núcleos. Por lo que nombramos a esta función como \texttt{desugar} y queda definida como sigue:
\[
\texttt {desugar :: =} \Rightarrow \texttt{Sugared\_ASA} \rightarrow \texttt{Desugared\_ASA}
\]
  
\begin{itemize}
\item \textbf{Variables:}
  Las variables no necesitan desazucarizarse pues ya son expresiones atómicas, ya pertenecen al núcleo, simplemente renombramos a ASA sin azúcar preservando el valor.
  \begin{center}
  \texttt{desugar}(\texttt{SugarVar i}) $\Rightarrow$ \texttt{Var i}\\
  \texttt{desugar}(\texttt{SugarNum n}) $\Rightarrow$ \texttt{Num n}\\
  \texttt{desugar}(\texttt{SugarBool b}) $\Rightarrow$ \texttt{Bool b}
  \end{center}

\begin{tcolorbox} [title=\textbf{Corrección 12: Corrección sobre SugarVar }, colframe=red!75!black, colback=red!5!white]
Fue un error de notación en el texto. Intenté diferenciar visualmente el ASA del AST usando el prefijo Sugar.

    \begin{center}
    \texttt{desugar}(\texttt{Var } $i$) $\Rightarrow$ \texttt{VarC } $i$\\
    \texttt{desugar}(\texttt{Num } $n$) $\Rightarrow$ \texttt{NumC } $n$\\
    \texttt{desugar}(\texttt{Boolean } $b$) $\Rightarrow$ \texttt{BoolC } $b$
    \end{center}
\end{tcolorbox}
  
\item \textbf{Operadores:}
  Nuestros operadores en su gran mayoría son variádicos, preservan la lista de ASA (los operandos), esto es azúcar sintáctica para el intérprete ya que nuestros operadores \texttt{+}, \texttt{-}, \texttt{*} y \texttt{/} son binarios. Por lo que podemos representar a los operadores variádicos como un encademiento del mismo. Por ejemplo:
  \begin{center}
  \texttt{desugar}(\texttt{SugarAdd[} $n_1,\:n_2,\ldots,\:n_k$\texttt{]}) $\Rightarrow$ \texttt{Add} $n_1$ (\texttt{Add} $n_2 \ldots$ (\texttt{Add} $n_{k-1}\; n_k$))
  \end{center}
  
\begin{tcolorbox} [title=\textbf{Corrección 13: Transformación composicional no entendida }, colframe=red!75!black, colback=red!5!white]
\item \textbf{Operadores:}
  Nuestros operadores en el ASA son variádicos (\texttt{Add}), preservan la lista de operandos. Esto es azúcar sintáctica para el intérprete, ya que en el núcleo (\texttt{AST}) nuestros operadores \texttt{AddC}, \texttt{SubC}, \texttt{MulC} y \texttt{DivC} son binarios.
  Por lo que representamos la desazucarización como un plegado de la lista. Por ejemplo:

  \[
  \texttt{desugar}(\texttt{Add }[e_1, e_2, \ldots, e_n]) \Rightarrow \texttt{AddC}(\texttt{desugar}(e_1), \texttt{desugar}(\texttt{Add}[e_2, \ldots, e_n]))
  \]
  
\end{tcolorbox}
  

  Para el caso de los operadores unarios, estos ya de por sí son azúcar sintáctica a excepción de Sqrt el cuál es un operador único por lo que ya es \textit{núcleo}. En el caso de \texttt{Add1} $n$ y \texttt{Sub1} $n$ podemos reexpreasarlos como  $n + 1$ y $n - 1$ respectivamente, y de manera similar con \texttt{Expt}, dado que en nuestro lenguaje representa elevar al cuadrado el número $n$, entonces \texttt{Expt} es azúcar sitáctica y lo reexpresamos como una multiplicación se $n \times n$:
  \begin{center}
  \texttt{desugar}(\texttt{Add1 } $n$) $\Rightarrow$ \texttt{Add} $n$ $1$\\
  \texttt{desugar}(\texttt{SugarSqrt } $n$) $\Rightarrow$ \texttt{Sqrt} $n$\\
  \texttt{desugar}(\texttt{Expt} $n$) $\Rightarrow$ \texttt{Mul} $n$ $n$
  \end{center}


\begin{tcolorbox} [title=\textbf{Corrección 14: Formalización de constructores con el prefijo Sugar}, colframe=red!75!black, colback=red!5!white]

Para el caso de los operadores unarios, algunos son azúcar pura, a excepción de \texttt{Sqrt}, el cual se transforma directamente al constructor del núcleo \texttt{SqrtC}.
  En el caso de \texttt{Add1} $n$ y \texttt{Sub1} $n$, podemos reexpresarlos como $n + 1$ y $n - 1$ utilizando los operadores binarios del núcleo y constantes numéricas. De manera similar con \texttt{Expt}, que representa elevar al cuadrado ($n \times n$):

  \begin{center}
  \texttt{desugar}(\texttt{Add1 } $n$) $\Rightarrow$ \texttt{AddC} (\texttt{desugar } $n$) (\texttt{NumC } 1)\\
  \texttt{desugar}(\texttt{Sub1 } $n$) $\Rightarrow$ \texttt{SubC} (\texttt{desugar } $n$) (\texttt{NumC } 1)\\
  \texttt{desugar}(\texttt{Sqrt } $n$) $\Rightarrow$ \texttt{SqrtC} (\texttt{desugar } $n$)\\
  \texttt{desugar}(\texttt{Expt } $n$) $\Rightarrow$ \texttt{MulC} (\texttt{desugar } $n$) (\texttt{desugar } $n$)
  \end{center}

\end{tcolorbox}

\item \textbf{Comparadores:}
  En el caso de los comparadores, es muy similar su representación en \textbf{ASA} sin azúcar como lo fue para los operadores variádicos, ya que estos también lo son. El núcleo de cada comparadaor es el mismo pues forzosamente tenemos que definir uno  para cada uno de ellos, ya que necesitamos preservar el tipo de comparación. Sin embargo, a diferencia de los operadores, no es conveniente representarlos como un encademiento de comparadores, pues al evaluar la comparación entre dos números, el resultado es de tipo \texttt{Bool}, sino como un encademiento de condicionales if.
  Donde la condición inicial es la comparación de los dos primeros argumentos y el consecuente son las comparaciones de la argumentos restantes, si alguna de las condiciones no se cumple entonces caemos en el else False y de otro modo las comparaciones son válidas y el resultado es \texttt{True}:

  \begin{center}
    \texttt{desugar}(\texttt{SugarEqual[} $n_1,\:n_2,\ldots,\:n_k$\texttt{]}) $\Rightarrow$ \texttt{If} (\texttt{Equal} $n_1$ $n_2$) (\texttt{Equal} $n_2$ $n_3$) $\ldots$ (\texttt{Equal} $n_{k-1}$ $n_k$) (\texttt{Bool False})
  \end{center}

\begin{tcolorbox} [title=\textbf{Corrección 15: Transformación correcta del SugarEqual}, colframe=red!75!black, colback=red!5!white]

La transformación correcta es un \textbf{encadenamiento de condicionales anidados} (\texttt{IfC}). La lógica es: comparamos los dos primeros elementos; si son iguales, procedemos a comparar el segundo con el tercero (en la rama \textit{then}), y así sucesivamente. Si alguna comparación falla, caemos inmediatamente en la rama \textit{else} con \texttt{BoolC False}.

  \begin{center}
    \texttt{desugar}(\texttt{Equal [} $n_1, n_2, \ldots, n_k$ \texttt{]}) $\Rightarrow$ \\
    \texttt{IfC} (\texttt{EqualC} $n_1$ $n_2$)
      (\texttt{IfC} (\texttt{EqualC} $n_2$ $n_3$) (\ldots \texttt{BoolC True}) (\texttt{BoolC False}))
      (\texttt{BoolC False})
  \end{center}

  De este modo, respetamos que el constructo \texttt{IfC} del núcleo es ternario y no variádico.

\end{tcolorbox}

\item \textbf{Not y Pares:}
\texttt{Not} y las \textbf{ASA} sobre pares \texttt{Pair}, \texttt{Fst} y \texttt{Snd} ya son núcleos, no hace falta definir una desazucarización específica.

\begin{tcolorbox} [title=\textbf{Corrección 16: Pares y Not}, colframe=red!75!black, colback=red!5!white]
\item \textbf{Not y Pares:}
  Aunque los constructos \texttt{Not}, \texttt{Pair}, \texttt{Fst} y \texttt{Snd} tienen una correspondencia directa en el núcleo, en la implementación \textbf{sí} es necesario definir una regla de transformación explícita.
  Esto se debe a que primero, debemos traducir del tipo de dato de la superficie (\texttt{ASA}) al tipo del núcleo (\texttt{AST}) cambiando los constructores (por ejemplo, de \texttt{Pair} a \texttt{PairC}) y ademas es indispensable propagar la desazucarización a sus sub-expresiones recursivamente.

  \begin{center}
    \texttt{desugar}(\texttt{Not } $e$) $\Rightarrow$ \texttt{NotC} (\texttt{desugar } $e$)\\
    \texttt{desugar}(\texttt{Pair } $e_1$ $e_2$) $\Rightarrow$ \texttt{PairC} (\texttt{desugar } $e_1$) (\texttt{desugar } $e_2$)\\
    \texttt{desugar}(\texttt{Fst } $e$) $\Rightarrow$ \texttt{FstC} (\texttt{desugar } $e$)\\
    \texttt{desugar}(\texttt{Snd } $e$) $\Rightarrow$ \texttt{SndC} (\texttt{desugar } $e$)
  \end{center}
  
\end{tcolorbox}

\item \textbf{Condicionales:}
  \texttt{If0} y \texttt{Cond} solo son azúcar sintáctica de \texttt{If}. \texttt{If0} como mencionamos es comprobar que el resultado al terminar de evaluarse sea igual a cero. Mientras que \texttt{Cond} es igualmente un encadenamiento de \texttt{If}. Por ello estas tres expresiones las representamos como un único núcleo If:

  \begin{center}
    \texttt{desugar}(\texttt{If0 c t e}) $\Rightarrow$ \texttt{If} (\texttt{Equal c 0}) t e\\
    \texttt{desugar}(\texttt{Cond [$x_1$ $e_1$] [$x_2$ $e_2$] $\ldots$ [$x_n$ $e_n$] [else $e_k$]}) $\Rightarrow$ \texttt{If} ($x_1$) $e_1$ (If ($x_2$) $n_2$) $\ldots$ (If ($x_n$) $e_n$ ($e_k$))
  \end{center}

\begin{tcolorbox} [title=\textbf{Corrección 17: Desugar IfO falta de desarrollo}, colframe=red!75!black, colback=red!5!white]

  Para \texttt{If0}, la transformación consiste en crear un \texttt{IfC} donde la condición es una comparación explícita con cero. Es crucial notar que debemos aplicar \texttt{desugar} recursivamente a las sub-expresiones ($c, t, e$) para asegurar que todo el árbol resultante pertenezca al núcleo.

  \begin{center}
    \texttt{desugar}(\texttt{If0 } $c\ t\ e$) $\Rightarrow$ \\
    \texttt{IfC} (\texttt{EqualC} (\texttt{desugar } $c$) (\texttt{NumC } 0)) (\texttt{desugar } $t$) (\texttt{desugar } $e$)
  \end{center}

  Por otro lado, \texttt{Cond} se desazucara como un encadenamiento de \texttt{IfC} anidados. Cada condición se transforma en un nivel del anidamiento, y el caso \texttt{else} final se convierte en la última rama alternativa.

  \begin{center}
    \texttt{desugar}(\texttt{Cond } [($c_1, e_1$), ($c_2, e_2$), $\dots$] \texttt{else } $e_{final}$) $\Rightarrow$ \\
    \texttt{IfC} (\texttt{desugar } $c_1$) (\texttt{desugar } $e_1$) \\
      (\texttt{IfC} (\texttt{desugar } $c_2$) (\texttt{desugar } $e_2$) (\dots (\texttt{desugar } $e_{final}$)\dots))
  \end{center}
\end{tcolorbox}
  
\item \textbf{Lets:}
  Los \texttt{Let} son solo la azúcar de la aplicación de funciones donde la sustitucion del valor con el identificador, el par (\textit{id, value}) es el argumento, y el cuerpo del \texttt{let} es la función que se va a aplicar. Por otro lado, \texttt{LetStar} es azúcar sintácica de \texttt{Let}, de modo que \texttt{LetStar} se reexpresa como \texttt{lets} anidados.
  
  Por lo que el proceso de desazucarización sería similar a:

  \begin{center}
    \texttt{desugar}(\texttt{Let}($id$, $value$) $body$)  $\Rightarrow$ \texttt{App} ($body$) ($id$, $value$)\\
    \texttt{desugar}(\texttt{LetStar}($id_1$, $value_1$) ($id_2$, $value_2$) $\ldots$ ($id_n$, $value_n$) $body$) $\Rightarrow$ \texttt{Let} (($id_1$, $value_1$) (\texttt{Let} ($id_2$, $value_2$) $\ldots$ (\texttt{Let}($id_n$, $value_n$) $body$)))
  \end{center}

\begin{tcolorbox} [title=\textbf{Corrección 18: Lets y LetStar desglosado}, colframe=red!75!black, colback=red!5!white]
\item \textbf{Lets:}
  Los \texttt{Let} son azúcar sintáctica para la aplicación de funciones. Semánticamente, \texttt{let x = v in body} es equivalente a definir una función anónima $(\lambda x. body)$ y aplicarla al valor $v$.
  Por lo tanto, la desazucarización transforma el constructo en una aplicación (\texttt{AppC}) de una función (\texttt{FunC}), asegurando aplicar \texttt{desugar} recursivamente tanto al cuerpo como al valor ligado.

  \begin{center}
    \texttt{desugar}(\texttt{Let } [($i, v$)] $b$) $\Rightarrow$ \texttt{AppC} (\texttt{FunC } $i$ (\texttt{desugar } $b$)) (\texttt{desugar } $v$)
  \end{center}

  Por otro lado, \texttt{LetStar} es azúcar sintáctica de \texttt{Let} anidados (evaluación secuencial). Su transformación no genera directamente un AST final, sino que se reescribe como un \texttt{Let} que contiene otro \texttt{LetStar} (o el cuerpo final), y se vuelve a invocar \texttt{desugar} sobre el resultado de esta expansión.

  \begin{center}
    \texttt{desugar}(\texttt{LetStar } [($i_1, v_1$), ($i_2, v_2$), \dots] $b$) $\Rightarrow$ \\
    \texttt{desugar}(\texttt{Let } [($i_1, v_1$)] (\texttt{LetStar } [($i_2, v_2$), \dots] $b$))
  \end{center}

\end{tcolorbox}
  
Pasando al caso específico de \texttt{letrec}, este nos permite definir funciones recursivas locales. Formalmente, la recursión puede desazucararse utilizando un operador de punto fijo. Para lenguajes de evaluación ansiosa se utiliza el operador Z, que implementa recursión sin necesidad de auto-referencia explícita\cite{Baren-Lambda}.

\begin{center}
\texttt{desugar}(\texttt{LetRec}($id$, $value$)$body$) $\Rightarrow$ \texttt{Let} (($id$, App (Lambda ($id$) $value$)(Lambda ($id$) $value$)))
$body$
\end{center}

\begin{tcolorbox} [title=\textbf{Corrección 19: Corrigiendo al LetRec}, colframe=red!75!black, colback=red!5!white]

Pasando al caso específico de \texttt{LetRec}, este nos permite definir funciones recursivas locales. Dado que nuestro núcleo no soporta recursión directa (referencias circulares en el entorno), utilizamos el combinador de punto fijo $Z$ para desazucararlo.

En nuestra implementación, asumimos la existencia de un combinador $Z$ definido en el entorno global. La regla de transformación reescribe el \texttt{LetRec} como un \texttt{Let} estándar donde aplicamos $Z$ a la función lambda generada. Es fundamental notar que el resultado de esta reescritura es una expresión en sintaxis concreta (ASA) que debe ser procesada nuevamente por \texttt{desugar}.

\[
\texttt{desugar}(\texttt{LetRec } i\ v\ b) \Rightarrow \texttt{desugar}(\texttt{Let } [(i, \texttt{App } (\texttt{Var } "Z")\ [\texttt{Lambda } [i]\ v])]\ b)
\]

De esta manera, transformamos la recursión implícita en una aplicación explícita del operador de punto fijo, delegando la resolución de la recursión a la semántica del combinador $Z$ durante la evaluación.
\end{tcolorbox}

\begin{quote}
En el trabajo \textit{The Formal of Programming Languages}, el concepto de punto fijo es la herramienta matemática fundamental para dar un significado preciso a las construcciones recurisivas de un lenguaje, como los bucles y las funciones que se llaman a sí mismas~\cite{winskel} 
\end{quote}

\begin{center}
El \textbf{combinador de punto fijo Z} se define en cálculo lambda como:
\[
Z = \lambda f. (\lambda x. f \, (\lambda y. x \, x \, y)) \, (\lambda x. f \, (\lambda y. x \, x \, y))
\]
que satisface la propiedad:
\[
Z \, F = F \, (Z \, F) \quad \text{para cualquier término } F
\] \cite{Baren-Lambda}
\end{center}

\textit{¿Por qué es necesario el combinador Z de punto fijo?}
En la implementación de nuestro MiniLisp, hemos definido las funciones anónimas ($\lambda$) como un núcleo fundamental del lenguaje. Esta decisión se tomo con el fin de poder desazucarar  muchas construcciones del lenguaje.Por ejemplo, let y letstar pueden ser traducidos de forma directa a simples aplicaciones de lambda.

Sin embargo, letrec (la construcción que permite definir funciones recursivas) presenta un desafío.

La recursión, se basa en nombres: una función se llama a sí misma por su propio nombre hasta llegar a un caso base. Pero esto crea una paradoja en nuestro sistema: si el núcleo solo entiende de funciones anónimas, ¿cómo puede una función sin nombre llamarse a sí misma?

Es aquí donde la teoría del punto fijo se vuelve clave.

En lugar de intentar que la función se llame a sí misma (lo cual es imposible sin un nombre), se crea una función "generadora" (un funcional), llamémosla $G$. Esta función $G$ no es recursiva, sino que acepta un argumento. Dicho argumento, llamémoslo $g$, representa la suposición de la función recursiva.

Para solucionar esto es necesario el uso de una "maquina"
que haga esto automáticamente. Esa máquina es un combinador de punto fijo (como el Combinador Y visto en clase).

\begin{tcolorbox} [title=\textbf{Corrección 20: Corrigiendo al LetRec}, colframe=red!75!black, colback=red!5!white]
En lugar de definir una función que se llame a sí misma por nombre, definimos un funcional (una función de orden superior), al que llamaremos $G$. Este funcional $G$ no es recursivo por sí mismo; en su lugar, recibe un argumento extra, digamos $f$, que servirá como el mecanismo para realizar las llamadas futuras. Es decir, $f$ actúa como un placeholder o sustituto de la propia función recursiva.

Sin embargo, $G$ por sí sola no puede ejecutarse indefinidamente. Necesitamos un mecanismo que, en tiempo de ejecución, se encargue de suministrar a $G$ una referencia a sí misma cada vez que sea necesario. Este mecanismo es el Combinador de Punto Fijo (en nuestro caso, el combinador $Z$, adecuado para evaluación estricta). Matemáticamente, el combinador calcula el punto fijo de $G$, construyendo efectivamente la función recursiva al "pasar" la función como argumento a sí misma de manera automática \cite{Friedman1996}
\end{tcolorbox}

\item \textbf{Expresiones lambda:}
  Nuestras expresiones lambda son variádicas, por lo que para representarlas en núcleo necesitamos currificarlas., es decir, necesitamos convertiralas en funciones de un solo argumento:
  
  \begin{center}
    \texttt{desugar}(\texttt{Lambda [$x_1$, $x_2$, $\ldots$ $x_n$]} $b$) $\Rightarrow$ (\texttt{Fun $x_1$ (Fun $x_2$ $\ldots$ (Fun $x_n$} $b$)))
  \end{center}
  
  De igual forma para la aplicación de funciones, ya que \texttt{App} en \textbf{ASA} maneja una lista de argumentos, necesitamos currificar estos argumentos ya que las funciones ya están en forma de un argumento a la vez:
  
  \begin{center}
    \texttt{desugar}(\texttt{App $e$ [$x_1$, $x_2$, $\ldots$ $x_n$]}) $\Rightarrow$ (\texttt{App} (\texttt{App} (\texttt{App} $\ldots$ (\texttt{App} $e$ $x_1$) $x_2$) $\ldots$) $x_n$))
  \end{center}
  
\item \textbf{Listas:}
  Para las listas definimos su desazucaricación con el uso de \texttt{Nil} y \texttt{Cons}, el cuál funciona de manera similar al encadenamiento de pares:
  
  \begin{center}
    \texttt{desugar}(\texttt{List [$x_1$, $x_2$, $\ldots$ $x_n$]}) $\Rightarrow$ (\texttt{Cons $x_1$ (Cons $x_2$ $\ldots$ (Con $x_{n-1}$ $x_n$}))
  \end{center}

\begin{tcolorbox}[title=\textbf{Corrección 21: Lambda y Listas }, colframe=red!75!black, colback=red!5!white]

\item \textbf{Expresiones Lambda:}
  Nuestras expresiones lambda en ASA son variádicas. Para representarlas en el núcleo (AST), necesitamos currificarlas, transformándolas en una serie de funciones unarias anidadas (\texttt{FunC}).
  
  \[
  \texttt{desugar}(\texttt{Lambda } [x_1, x_2, \ldots, x_n]\ b) \Rightarrow \texttt{FunC } x_1 (\texttt{FunC } x_2 \ldots (\texttt{FunC } x_n (\texttt{desugar } b))\ldots)
  \]
  
  De igual forma para la \textbf{aplicación de funciones}, ya que \texttt{App} en \textbf{ASA} maneja una lista de argumentos, necesitamos currificar la aplicación utilizando \texttt{AppC} (que es binaria), respetando la asociatividad por la izquierda y desazucarando tanto la función como cada argumento:
  
  \[
  \texttt{desugar}(\texttt{App } e\ [x_1, \ldots, x_n]) \Rightarrow \texttt{AppC } (\ldots (\texttt{AppC } (\texttt{desugar } e) (\texttt{desugar } x_1)) \ldots) (\texttt{desugar } x_n)
  \]
  
\item \textbf{Listas:}
  Para las listas, definimos su desazucarización utilizando el constructor \texttt{ConS}. Es importante notar que, según nuestra implementación en Haskell (donde el caso base para un solo elemento devuelve el elemento procesado), la estructura resultante es un encadenamiento donde el último elemento es el final de la estructura, sin utilizar \texttt{NiL} como terminador explícito para listas no vacías.
  
  \[
  \texttt{desugar}(\texttt{List } [x_1, \ldots, x_n]) \Rightarrow \texttt{ConS } (\texttt{desugar } x_1) (\texttt{ConS } \ldots (\texttt{ConS } (\texttt{desugar } x_{n-1}) (\texttt{desugar } x_n))\ldots)
  \]

\end{tcolorbox}

De esta manera, la estructura superficial de las listas en la sintaxis concreta, que aparenta ser n-aria se reexpresa en términos de una estructura binaria en el núcleo del lenguaje. En otras palabras, una lista como \texttt{[a,b,c]} no es realmente un nodo con tres hijos, sino una secuencia anidada de constructores
\texttt{Cons}, cada uno tomando dos argumentos: el elemento y la referencia al resto de la lista. 

Esto implica que algunas construcciones que originalmente se representan como árboles n-arios en el \textbf{ASA}, después de ser desazucarizadas corresponden a árboles binarios en el \textbf{AST}. \texttt{Head}, \texttt{Tail} ya no operan sobre listas \textbf{ASA}, sino directamente sobre la estructura \texttt{Nil} y \texttt{Cons}, que constituye el núcleo semántico para listas.

\begin{tcolorbox}[title=\textbf{Corrección 22: Corrección del texto}, colframe=red!75!black, colback=red!5!white]
Esto implica que algunas construcciones que originalmente se representan como árboles n-arios en el ASA, después de ser desazucarizadas corresponden a árboles binarios en el AST. 
\texttt{Head} y \texttt{Tail} ya no operan sobre listas ASA, sino directamente sobre la estructura \texttt{ConS}, que constituye el núcleo semántico principal para las listas en nuestra implementación (donde el final de la lista es el propio elemento y no un terminador explícito).
\end{tcolorbox}

\end{itemize}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Desugar en Haskell}

Para nuestro proyecto en \minilisp definimos el siguiente tipo de dato:

\begin{lstlisting}[style=haskellstyle, caption={Tipo de dato ASA sin azúcar, AST}]
module AST where
  
-- ASA sin azucar (AST)
data AST
  = VarC String
  | NumC Int
  | BoolC Bool
  | AddC AST AST
  | SubC AST AST
  | MulC AST AST
  | DivC AST AST
  | SqrtC AST
  | NotC AST
  | EqualC AST AST
  | LessC AST AST
  | GreaterC AST AST
  | DiffC AST AST
  | LeqC AST AST
  | GeqC AST AST
  | PairC AST AST
  | FstC AST
  | SndC AST
  | IfC AST AST AST
  | FunC String AST
  | AppC AST AST
  | ConS AST AST
  | HeadC AST
  | TailC AST
  | NiL
  deriving (Show, Eq)

\end{lstlisting}

\begin{tcolorbox}[title=\textbf{Corrección 23: Nota sobre notación}, colframe=red!75!black, colback=red!5!white]
En las cajas anteriores se corrige los nombres de los constructores.
\end{tcolorbox}

\textbf{AST} (\textit{Abstract Sintaxis Tree}) es nuestro tipo de dato \textbf{ASA} sin azúcar, no hay un razón especial por la que la hayamos nombrado \textbf{AST}, nos pareció práctico y nada más. En esta seccón nos referiremos como \textbf{AST} a nuestra sintaxis abstracta sin azúcar en\minilisp\hspace{-0.2cm}. Notemos que, los tipos de dato que trabajaban sobre listas\\

\begin{tcolorbox}[title=\textbf{Corrección 24: Redacción formal}, colframe=red!75!black, colback=red!5!white]

El \textbf{AST} \textit{Abstract Syntax Tree} constituye nuestro tipo de dato para la representación de \textbf{ASA} (\textit {Árbol de Sintaxis Abstracta}) sin azúcar sintáctico. La elección de la denominación \textbf{AST} responde principalmente a consideraciones prácticas de implementación, sin implicaciones semánticas adicionales. 

\end{tcolorbox}

Anteriormente hicimos una breve mención, casi de manera superficial, de cómo se re-expresan nuestro \textbf{ASA} a \textbf{AST} a través de un función especial conocida como \texttt{desugar}, de tal modo que nos quedamos con las estructuras núcleo y no ahorramos futuras reglas para el intérprete.\\

En nuestro proyecto de\minilisp\hspace{-0.2cm}, definimos la función \texttt{desugar} en el arhcivo \texttt{Desugar.hs} como sigue:

\begin{lstlisting}[style=haskellstyle, caption={Firma y casos base de la función desugar}]
  module Desugar where
  
  import ASA
  import AST
  import ASV
  
  {-- Desazucaramos los ASA  --}
  desugar :: ASA -> AST
  -- Casos base
  desugar (Var x) = VarC x
  desugar (Num n) = NumC n
  desugar (Boolean b) = BoolC b
\end{lstlisting}

La firma de la función refleja nuestro objetivo, dado una estructura \texttt{ASA}, \texttt{desugar} lo procesa hasta obtener un \texttt{AST}. Nótese además que las expresiones atómicas no cambian su estructura, únicamente las renombramos de tipo \texttt{ASA} a \texttt{AST}.

\begin{lstlisting}[style=haskellstyle, caption={Sección de la función \texttt{desugar} para operadores aritméticos}]
  desugar :: ASA -> AST
  -- Operaciones aritmeticas
  desugar (Add xs) = desugarOps AddC xs
  desugar (Sub xs) = desugarOps SubC xs
  desugar (Mul xs) = desugarOps MulC xs
  desugar (Div xs) = desugarOps DivC xs
  desugar (Add1 n) = AddC (desugar n) (NumC 1)
  desugar (Sub1 n) = SubC (desugar n) (NumC 1)
  desugar (Expt n) = MulC (desugar n) (desugar n)
  desugar (Sqrt n) = SqrtC (desugar n)
\end{lstlisting}

Previamente, al hacer mención de la función \texttt{desugar} omitimos explicar que los argumentos de las expresiones deben pasar también por el proceso de desazucarización, sin embargo es necesario definir la desazucarización recursivamente ya que como sabemos, un \textbf{AST} es \textbf{AST} si todos sus hijos lo son.

\begin{tcolorbox}[title=\textbf{Corrección 25: Redacción formal}, colframe=red!75!black, colback=red!5!white]
Previamente, presentamos la función \texttt{desugar} enfocándonos en la transformación del nodo raíz. Sin embargo, para garantizar la correctitud del programa, la definición debe ser recursiva. Dado que el \textbf{AST} es una estructura de árbol, la propiedad de "estar desazucarado" debe cumplirse en cada uno de sus nodos. Por lo tanto, la función se aplica no solo a la expresión principal, sino que se distribuye a través de todos los argumentos de las expresiones compuestas.
\end{tcolorbox}

\noindent
Para ello definimos una función auxiliar \texttt{desugarOps} que generaliza el trabajo de desazucarar las operaciones aritméticas pues estas pasan por el mismo procedimiento solo que cambian la etiqueta de su estructura. Mientras que \texttt{Add1} y \texttt{Sub1} como mencionamos, son azúcar para $n$ \texttt{+} 1 / $n$ \texttt{-} 1 respectivamente, además de que \texttt{Expt} es azúcar de $n \times n$. Por otro lado, \texttt{Sqrt} solo pasa a ser \texttt{SqrtC} además que aplica \texttt{desugar} a su único hijo.

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{desugarOps} como auxiliar para desazucarar operadores}]
  desugar :: ASA -> AST
  -- Operaciones aritmeticas
  desugar (Add xs) = desugarOps AddC xs
  desugar (Sub xs) = desugarOps SubC xs
  desugar (Mul xs) = desugarOps MulC xs
  desugar (Div xs) = desugarOps DivC xs

  --Funcion auxiliar para desazucarar los operadores
  desugarOps :: (AST -> AST -> AST) -> [ASA] -> AST
  desugarOps _ [] = error "[desugarOps Error]: Lista vacia (no deberia suceder)"
  desugarOps _ [x] = desugar x
  desugarOps op (x:xs) = op (desugar x) (desugarOps op xs)
\end{lstlisting}

La función \texttt{desugarOps} recibe una tupla de \texttt{AST} (\texttt{AST -> AST -> AST}) y una lista de \texttt{ASA} y devuelve un \texttt{AST} donde en la tupla, el primero es la etiqueta asociada al operador que vamos a desazucarar y los otros dos son los hijos del operador, que recordemos, en \texttt{AST} ya son árboles binarios. Y la lista de \texttt{ASA} es la lista de los operandos que vamos a separar.

\begin{tcolorbox}[title=\textbf{Corrección 26: Auxiliar desugarOps}, colframe=red!75!black, colback=red!5!white]
La función \texttt{desugarOps} recibe como primer argumento una función constructora binaria del núcleo \texttt{AST -> AST -> AST} por ejemplo \texttt{AddC o MulC} y como segundo argumento las lista de términos \texttt{ASA} que se deben procesar.
\end{tcolorbox}

\noindent
De esta forma no perdemos la referencia de qué tipo de operador \texttt{AST} estamos desazucarando mientras mantemos una única función \texttt{desugarOps} y así no tenemos que definir una función para cada operador.

\noindent
Tenemos dos casos base para la función, donde \texttt{[ASA]} es vacía, cosa que no debería suceder pues en la gramática definida en Happy justo lo implementamos de modo que los operadores rechacen un número de argumentos inválidos; además de que tampoco se puede llegar a la lista vacía por el siguiente caso base donde si la lista tiene un elemento es donde termina la recursión y devolvemos ese elemento desazucarado con \texttt{desugar}. Por otro lado el paso recursivo es donde tomamos la cabeza de la lista el cual desazucaramos para ser el primer arguemento del operador, mientras que la cola recursivamente se aplica \texttt{desugarOps} y que será el segundo argumento.\\

Continuando con los comparadores, intuitivamente pensamos en implementarlo de igual forma que con los operadores (un encadenamiento de comparadores). Sin embargo, al momento de pensar en su interpretación, nos topamos con el problema de que, al hacer la comparación entre un \texttt{Num n} y \texttt{Num m}, el resultado es de tipo \texttt{Bool}, y esto nos da una inconsistencia de tipos al momento de continuar con las evaluaciones posteriores ya que no es imposible comparar un \texttt{Num} con un \texttt{Bool}.

\noindent
Por ello cambiamos su implementación a encadenamiento de condicionales \texttt{If}, pues es la única forma en nuestro lenguaje de preservar las comparaciones correctas y detectar en donde no se cumple la comparación.

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{desugarComp} como auxiliar para desazucarar comparadores}]
  desugar :: ASA -> AST
  -- Not
  desugar (Not x) = NotC (desugar x)
  -- Comparaciones
  desugar (Equal xs) = desugarComp EqualC xs
  desugar (Less xs) = desugarComp LessC xs
  desugar (Greater xs) = desugarComp GreaterC xs
  desugar (Diff xs) = desugarComp DiffC xs
  desugar (Leq xs) = desugarComp LeqC xs
  desugar (Geq xs) = desugarComp GeqC xs

  --Funcion auxiliar para desazucarar los comparadores
  desugarComp :: (AST -> AST -> AST) -> [ASA] -> AST
  desugarComp _ [] = BoolC True
  desugarComp _ [_] = BoolC True
  desugarComp op [i, d] = op (desugar i) (desugar d)
  desugarComp op (i:d:is) = IfC (op (desugar i) (desugar d))
                            (desugarComp op (d:is))
                            (BoolC False)
\end{lstlisting}

\begin{tcolorbox}[title=\textbf{Corrección 27: Nota sobre el caso base de la recursión desugarComp}, colframe=red!75!black, colback=red!5!white]
Se podría pensar que el caso base \texttt{desugarComp \_ [\_] = BoolC True} ignora el último elemento de la lista al no aplicar \texttt{desugar} explícitamente sobre él.
  Sin embargo, dada la naturaleza recursiva de nuestra función, este último elemento \textbf{ya ha sido procesado y desazucarado} en el paso anterior de la recursión, donde actuó como el operando derecho de la comparación (el elemento \texttt{d} en el patrón \texttt{i:d:is}).
  Por lo tanto, volver a procesarlo en el caso base sería redundante. Para el caso borde de una comparación con un único argumento (ej. \texttt{(= 5)}), asumimos la verdad vacua sin efectos secundarios, consistente con la simplificación del núcleo.

\textbf{Nota sobre la separación de casos:}
  Aclarando la distinción entre el patrón \texttt{[i, d]} y el caso recursivo general \texttt{(i:d:is)}.
  Aunque teóricamente el patrón general podría capturar listas de dos elementos (donde la cola \texttt{is} sería vacía), esto resultaría en la generación de una estructura condicional redundante de la forma \texttt{IfC (op i d) True False}.
  
  Por esta razón, hemos optado por \textbf{aislar el caso base de dos elementos}. Esta decisión constituye una optimización sintáctica que permite generar directamente el nodo de comparación (\texttt{op i d}) sin envoltorios innecesarios, produciendo un AST más limpio y reduciendo la sobrecarga computacional durante la evaluación.
\end{tcolorbox}

De manera similar como fue con los operadores, definimos una función \texttt{desugarComp} que recibe una tupla de \texttt{AST} para preservar la etiqueta a desazucarar y la lista de elementos a separar que se van a comparar. Los primeros dos casos, son los casos base, donde igualmente, no podemos tener una lista de uno o ningún elemento, pues. La siguiente instrucción sería nuestro caso base real, donde establece que al tener solo dos elementos en la lista, simplemente se devuela la comparación de ambos elementos, mientras que si todavía quedan elementos en la lista, iniciemos la cadena de \texttt{IfC}, donde los primeros dos elementos se comparan en la condición y en caso de cumplirse continuamos en el entonces con la llamada recursiva de \texttt{desugarComp} del segundo elemento con el resto de la lista, y en caso de no cumplirse, el else es \texttt{BoolC False}.

\noindent
Esta separación y comparación de elementos es válida para cualquier lista de $n$ elementos sin importar si $n$ es $2k$ o $2k$ \texttt{-} $1$, es decir, si la lista tiene un número impar o par de elementos; ya que siempre hacemos la comparación de elemento por elemento hasta llegar al caso donde quedan 2 elementos en la lista que es cuando simplemente se devuelve la comparación de ambos.\\

Los pares como se mencionó no es necesario desazucararlos más que recursivamente desazucarar a sus hijos:

\begin{lstlisting}[style=haskellstyle, caption={Desazucarización de los Pares}]
  desugar :: ASA -> AST
  -- Pares
  desugar (Pair f s) = PairC (desugar f) (desugar s)
  desugar (Fst p) = FstC (desugar p)
  desugar (Snd p) = SndC (desugar p)
\end{lstlisting}

Como bien explicamos, las condicionales \texttt{If0} y \texttt{Cond} son azúcar sintáctica de \texttt{If}. \texttt{If0} pasa a \texttt{IfC} con la comprobación de que el valor en la condición sea igual a cero y nada más. 

\begin{lstlisting}[style=haskellstyle, caption={Desazucarización de los condicionales}]
  desugar :: ASA -> AST
  --Condicionales
  desugar (If0 c t e) = IfC (EqualC (desugar c) (NumC 0)) (desugar t) (desugar e)
  desugar (If c t e) = IfC (desugar c) (desugar t) (desugar e)
  desugar (Cond cs e) = desugarCond cs e
\end{lstlisting}

Por otro lado para \texttt{Cond}, tenemos que definir una función auxiliar que nos realice el paso a encadenamiento de condicionales \texttt{IfC}

\begin{lstlisting}[style=haskellstyle, caption={Desazucarización de Cond}]
  desugar :: ASA -> AST
  --Condicionales
  desugar (Cond cs e) = desugarCond cs e

  --Funcion auxiliar para desazucarar el operador cond
  desugarCond :: [(ASA, ASA)] -> ASA -> AST
  desugarCond [] e = desugar e
  desugarCond ((c, t):cs) e = IfC (desugar c) (desugar t) (desugarCond cs e)
\end{lstlisting}

Como se puede ver, la función \texttt{desugarCond} recibe una lista de pares (\textit{condición, expresión}) junto con una expresión final (el caso \texttt{else} implícito). Si la lista de pares es vacía, basta con devolver la expresión por defecto desazucarada. En caso contrario, se construye una estructura \texttt{IfC} donde la primera condición se evalúa en el \textit{\textbf{if}}, la primera expresión en el \textit{\textbf{then}}, y el resto de los pares en el \textit{\textbf{else}}, aplicando recursivamente \texttt{desugarCond}.

\noindent
De esta manera, la estructura \texttt{Cond} se traduce en una sucesión de evaluaciones \texttt{IfC} anidadas, logrando así preservar el mismo comportamiento semántico que tendría en su forma azucarada. Y así garantizamos que sólo se ejecute el cuerpo correspondiente a la primera condición verdadera, respetando la naturaleza secuencial del condicional múltiple.\\

Como se mencionó, los \texttt{Let} en nuestro lenguaje no son construcciones primitivas, sino azúcar sintáctica que se puede expresar completamente a partir de funciones y aplicaciones. Intuitivamente, un \texttt{Let} introduce una variable local asociada a un valor dentro de un cuerpo de expresión. Sin embargo, esta noción de “sustitución” puede modelarse directamente mediante la aplicación de una función anónima a un argumento\cite{Dybving}.

\noindent
Esta equivalencia se refleja directamente en nuestra función auxiliar \texttt{desugarLet}, encargada de traducir cualquier \texttt{Let} del \textbf{ASA} a su correspondiente expresión \textbf{AST} basada en aplicaciones de funciones:

\begin{lstlisting}[style=haskellstyle, caption={Desazucarización de Let y LetStar}]
  desugar :: ASA -> AST
  --Lets
  desugar (Let iv b) = desugarLet iv b
  desugar (LetStar [] body) = desugar body
  desugar (LetStar (iv:ivs) b) = desugar (Let [iv] (LetStar ivs b))

  --Funciones auxiliares para desazucarar let
  desugarLet :: [(String, ASA)] -> ASA -> AST
  desugarLet [] b = desugar b
  desugarLet ((p, v):ps) b = AppC (FunC p (desugarLet ps b)) (desugar v)
\end{lstlisting}

\begin{tcolorbox}[title=\textbf{Corrección 28: Nota sobre la semántica de Let y Let*}, colframe=red!75!black, colback=red!5!white]
  \textbf{Nota sobre la semántica de Let y Let*:}
  Es importante señalar que, debido a la naturaleza recursiva de nuestra función auxiliar \texttt{desugarLet}, las vinculaciones en el constructo \texttt{Let} se generan creando ámbitos anidados para cada variable.
  
  Esto implica que, en nuestra implementación actual, \texttt{Let} adopta una \textbf{semántica secuencial}, comportándose de manera idéntica a \texttt{Let*}. Aunque en Lisp estándar el \texttt{Let} realiza asignaciones paralelas (donde una variable no puede referenciar a otra definida en el mismo bloque), hemos optado por unificar ambos comportamientos. Esta decisión de diseño simplifica considerablemente la lógica de desazucarado, permitiendo utilizar un único mecanismo de abstracción recursiva para ambas estructuras sin perder capacidad expresiva.
\end{tcolorbox}

La función \texttt{desugarLet} recibe una lista de pares \texttt{(id, valor)} y el cuerpo del \texttt{Let}. En el caso base, cuando no hay más pares, simplemente se desazucara el cuerpo, ya que no hay variables locales restantes por introducir. En el caso general, se construye una función anónima con el primer identificador \texttt{p} y cuerpo el resultado de seguir desazucarando los pares restantes junto con el cuerpo \texttt{b}.
A continuación, esta función se aplica (\texttt{AppC}) al valor \texttt{v} correspondiente, el cual también se desazucara antes de la aplicación.\\

\begin{tcolorbox}[title=\textbf{Corrección 29: Sobre los Lets sin bindings}, colframe=red!75!black, colback=red!5!white]
La función \texttt{desugarLet} recibe una lista de pares $(id, valor)$ y el cuerpo del \texttt{Let}.
El caso base de la recursión ocurre cuando la lista de pares es vacía (lo cual corresponde sintácticamente a un \texttt{Let} sin vinculaciones, ej. \texttt{(let () body)}).
En esta situación, dado que no hay nuevas variables que introducir en el entorno, la expresión es semánticamente equivalente al cuerpo mismo, por lo que simplemente se devuelve el resultado de desazucarar dicho cuerpo (\texttt{desugar b}).
\end{tcolorbox}

Además, \texttt{LetStar} -como también se  mencionó en la sección anterior- es simplemente azúcar sintáctica de \texttt{Let}. El \texttt{LetStar} permite escribir múltiples asignaciones secuenciales en un mismo bloque, pero semánticamente equivale a una serie de \texttt{Let} anidados. Su desazucarización se implementa recursivamente, construyendo un \texttt{Let} por cada par \texttt{(id, valor)} y utilizando como cuerpo el siguiente \texttt{LetStar}, hasta llegar al cuerpo final.\\

Por otro lado tenemos el caso del \texttt{LetRec}:

\begin{lstlisting}[style=haskellstyle, caption={Desazucarización de LetRec}]
  desugar :: ASA -> AST
  ---LetRec
  desugar (LetRec i v b) = desugar (Let [(i, App (Var "Z") [Lambda [i] v])] b)
\end{lstlisting}

La construcción \texttt{letrec} permite la definición de funciones recursivas locales.
Dado que el núcleo del lenguaje no incluye recursión como mecanismo primitivo, esta
debe expresarse mediante azúcar sintáctica utilizando construcciones ya presentes,
como funciones anónimas y \texttt{let}.

La desazucarización transforma la expresión:
\[
\texttt{desugar}(\texttt{LetRec } i\ v\ b)
\]
en la siguiente forma equivalente:
\[
\texttt{desugar}(\texttt{Let } [(i, \texttt{App } (\texttt{Var } "Z")\ [\texttt{Lambda } [i]\ v])]\ b)
\]
Este patrón corresponde a la expansión operacional del combinador de punto fijo para
lenguajes con evaluación estricta (combinador \(Z\) mencionado anteriormente). La función \(\lambda i.\, v\) se
aplica a sí misma, permitiendo que \(i\) haga referencia a su propia definición dentro
de \(v\), sin necesidad de introducir recursión directamente en el núcleo semántico del
lenguaje.

\bigskip
De esta manera, \texttt{letrec} se reduce a una combinación de aplicación lambda y
\texttt{let*}, asegurando que el análisis y la ejecución posterior puedan realizarse de
acuerdo con las reglas ya definidas para el lenguaje base. Una vez realizada la
transformación, se invoca nuevamente a \texttt{desugar} para continuar el proceso hasta
obtener una expresión completamente desazucarizada en el árbol AST.

\bigskip

Una vez establecido lo anterior, continuamos con el caso de los \textbf{ASA} \texttt{Lambda} en nuestro lenguaje, operan con una lista de parámetros siendo esto azúcar sintáctica, por lo que definimos la función auxiliar \texttt{desugarLmb} done ''\textit{currificamos}`` la función en \texttt{FunC} que trabaja sobre un parámetro:

\begin{lstlisting}[style=haskellstyle, caption={Desazucarización de las funciones lambda}]
  desugar :: ASA -> AST
  --Expresiones lambda
  desugar (Lambda ps b) = desugarLmb ps b

  --Funcion auxiliar para desazucarar las funcioneslambda
  desugarLmb :: [String] -> ASA -> AST
  desugarLmb [] b = desugar b
  desugarLmb (p:ps) b = FunC p (desugarLmb ps b)
\end{lstlisting}

Si la lista de parámetros está vacía, simplemente se devuelve el cuerpo desazucarado; en caso contrario, se crea un \texttt{FunC} con el primer parámetro y como cuerpo el resultado de desazucarar los parámetros restantes junto con el cuerpo.

De igual manera, las aplicaciones de función en \texttt{ASA} trabajan con una lista de argumentos, por lo que debemos desazucarlo en aplicaciones sucesivas de \texttt{AppC}.

\begin{lstlisting}[style=haskellstyle, caption={Desazucarización de la aplicación de función}]
  desugar :: ASA -> AST
  --Expresiones lambda
  desugar (App f as) = desugarApp (desugar f) as

  --Funcion auxiliar para desazucarar las aplicaciones de funcion
  desugarApp :: AST -> [ASA] -> AST
  desugarApp f [] = f
  desugarApp f (a:as) = desugarApp (AppC f (desugar a)) as
\end{lstlisting}

Donde el caso base es que al quedarnos sin argumentos que desazcuarar, devolvemos la función a aplicar, ya que esta fue desazucarada en \texttt{AST} desde la primer llamada a \texttt{desugarApp}. Por otra parte, si quedan argumentos en la lista continuamos con la llamda recursiva para que formen las aplicaciones sucesivas de \texttt{AppC}.\\

Finalmente tenemos \texttt{desugar} para listas. En un principio, la idea fue implementar las listas como encademaiento de pares, no obstante, esto nos trajo problemas al momento de implementar la función que devuelve el resultado al usuario\footnote{Abordaremos más sobre esta situación en próximos capítulos pero en términos simples usar \texttt{ConS} y \texttt{NiL} mejoró la parte de diferenciar totalementre entre una lista con pares a un par con listas, entre otras combinaciones para poder reflejar correctamente la entrada del usuario sin modificaciones inesperadas.}, pero aunque realizar esta desazucarización requiere de definir cuatro \texttt{AST}, nos facilita el trabajo al momento de evaluar acertadamente lo que el usuario da como programa.

\begin{lstlisting}[style=haskellstyle, caption={Desazucarización de Listas}]
  desugar :: ASA -> AST
  --Listas
  desugar (List l) = desugarList l
  desugar (Head l) = HeadC (desugar l)
  desugar (Tail l) = TailC (desugar l)

  --Funcion auxiliar para construir listas como cons y nil
  desugarList :: [ASA] -> AST
  desugarList [] = NiL
  desugarList [x] = desugar x
  desugarList (x:xs) = ConS (desugar x) (desugarList xs)
\end{lstlisting}

\begin{tcolorbox}[title=\textbf{Corrección 30: Lista de un elemento}, colframe=red!75!black, colback=red!5!white]
Nuestro caso base \texttt{desugarList [x] = desugar x} implica que una lista que contiene un único elemento en el \textbf{ASA} se transforma directamente en dicho elemento atómico en el \textbf{AST}, perdiendo su estructura de lista.
  
Esto es consistente con nuestra implementación de listas impropias. En este esquema, la lista no termina con un marcador vacío explícito (\texttt{NiL}), sino que el último nodo \texttt{ConS} contiene el dato final directamente en su segunda posición. Por lo tanto, una lista de un solo elemento se reduce semánticamente al elemento mismo dentro de esta estructura simplificada, eliminando la necesidad de un nodo terminador adicional.
\end{tcolorbox}

De manera muy similar a como fuimos creando el encadenamiento de operadores o de condicionales \texttt{IfC} para los comparadores, en este caso, vamos elemento por elemento de la lista creando un encadenamiento de únicamente \texttt{ConS}, mas no utilizamos \texttt{NiL}. Este \texttt{AST} lo utilizamos de manera reservada para representar las listas vacías, mientras que \texttt{HeadC} y \texttt{TailC} son similares a \texttt{FstC} y \texttt{SndC} pero sobre listas.\\

De este modo terminamos con el algoritmo de la función \texttt{desugar} para desazucarar nuestros \textbf{ASA} y convertilos a \texttt{AST}:

\begin{lstlisting}[style=haskellstyle, caption={Algoritmo para función \texttt{desugar} en Haskell completo}]
  {-- Desazucaramos los ASA  --}
  desugar :: ASA -> AST
  -- Casos base
  desugar (Var x) = VarC x
  desugar (Num n) = NumC n
  desugar (Boolean b) = BoolC b
  -- Operaciones aritmeticas
  desugar (Add xs) = desugarOps AddC xs
  desugar (Sub xs) = desugarOps SubC xs
  desugar (Mul xs) = desugarOps MulC xs
  desugar (Div xs) = desugarOps DivC xs
  desugar (Add1 n) = AddC (desugar n) (NumC 1)
  desugar (Sub1 n) = SubC (desugar n) (NumC 1)
  desugar (Expt n) = MulC (desugar n) (desugar n)
  desugar (Sqrt n) = SqrtC (desugar n)
  -- Not
  desugar (Not x) = NotC (desugar x)
  -- Comparaciones
  desugar (Equal xs) = desugarComp EqualC xs
  desugar (Less xs) = desugarComp LessC xs
  desugar (Greater xs) = desugarComp GreaterC xs
  desugar (Diff xs) = desugarComp DiffC xs
  desugar (Leq xs) = desugarComp LeqC xs
  desugar (Geq xs) = desugarComp GeqC xs
  -- Pares
  desugar (Pair f s) = PairC (desugar f) (desugar s)
  desugar (Fst p) = FstC (desugar p)
  desugar (Snd p) = SndC (desugar p)
  --Condicionales
  desugar (If0 c t e) = IfC (EqualC (desugar c) (NumC 0)) (desugar t) (desugar e)
  desugar (If c t e) = IfC (desugar c) (desugar t) (desugar e)
  desugar (Cond cs e) = desugarCond cs e
  --Lets
  desugar (Let iv b) = desugarLet iv b
  desugar (LetStar [] body) = desugar body
  desugar (LetStar (iv:ivs) b) = desugar (Let [iv] (LetStar ivs b))
  --Let recursivo
  desugar (LetRec i v b) = desugar (Let [(i, App (Var "Z") [Lambda [i] v])] b)
  --Expresiones lambda
  desugar (Lambda ps b) = desugarLmb ps b
  desugar (App f as) = desugarApp (desugar f) as
  --Listas
  desugar (List l) = desugarList l
  desugar (Head l) = HeadC (desugar l)
  desugar (Tail l) = TailC (desugar l)

  {-- Funciones auxiliares para desugar --}
  --Funcion auxiliar para desazucarar los operadores
  desugarOps :: (AST -> AST -> AST) -> [ASA] -> AST
  desugarOps _ [] = error "[desugarOps Error]: Lista vacia (no deberia suceder)"
  desugarOps _ [x] = desugar x
  desugarOps op (x:xs) = op (desugar x) (desugarOps op xs)

  --Funcion auxiliar para desazucarar los comparadores
  desugarComp :: (AST -> AST -> AST) -> [ASA] -> AST
  desugarComp _ [] = BoolC True
  desugarComp _ [_] = BoolC True
  desugarComp op [i, d] = op (desugar i) (desugar d)
  desugarComp op (i:d:is) = IfC (op (desugar i) (desugar d))
  (desugarComp op (d:is))
  (BoolC False)
  
  --Funcion auxiliar para desazucarar el operador cond
  desugarCond :: [(ASA, ASA)] -> ASA -> AST
  desugarCond [] e = desugar e
  desugarCond ((c, t):cs) e = IfC (desugar c) (desugar t) (desugarCond cs e)

  --Funciones auxiliares para desazucarar let
  desugarLet :: [(String, ASA)] -> ASA -> AST
  desugarLet [] b = desugar b
  desugarLet ((p, v):ps) b = AppC (FunC p (desugarLet ps b)) (desugar v)

  --Funcion auxiliar para desazucarar las funcioneslambda
  desugarLmb :: [String] -> ASA -> AST
  desugarLmb [] b = desugar b
  desugarLmb (p:ps) b = FunC p (desugarLmb ps b)

  --Funcion auxiliar para desazucarar las aplicaciones de funcion
  desugarApp :: AST -> [ASA] -> AST
  desugarApp f [] = f
  desugarApp f (a:as) = desugarApp (AppC f (desugar a)) as

  --Funcion auxiliar para construir listas como cons y nil
  desugarList :: [ASA] -> AST
  desugarList [] = NiL
  desugarList [x] = desugar x
  desugarList (x:xs) = ConS (desugar x) (desugarList xs)
\end{lstlisting}

\bigskip

Concluimos así con la implementación del proceso de desazucarado de nuestros Árboles de Sintaxis Abstracta, obteniendo como resultado el núcleo fundamental de nuestro lenguaje \minilisp. Como vimos, este procedimiento es esencial, pues nos permite simplificar la estructura del lenguaje al eliminar construcciones sintácticas superficiales y reducirlas a formas más primitivas.

Este enfoque no solo disminuye la complejidad de las reglas necesarias para el intérprete, sino que también evita operaciones redundantes, facilitando el análisis, la evaluación y el mantenimiento del lenguaje. Además, garantiza el respeto absoluto a la intención del usuario, manteniendo intacta la semántica del programa original.

En resumen, la eliminación del azúcar sintáctica constituye una fase clave en el diseño de lenguajes funcionales, ya que nos permite trabajar con una base sólida, mínima y expresiva sobre la cual construir el resto de las capacidades del lenguaje, asegurando claridad, consistencia y elegancia en su implementación.

\bigskip
