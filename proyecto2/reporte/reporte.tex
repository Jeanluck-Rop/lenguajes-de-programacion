\documentclass[12pt,openany]{book}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[normalem]{ulem}
\usepackage[hidelinks]{hyperref}

\usepackage{listings, tcolorbox, xcolor, float}
\usepackage{algorithm, algpseudocode, chngcntr}
\usepackage{graphicx, enumitem, geometry}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{forest}
\usepackage{fancyhdr}

% ----- Custom Page -----
\geometry{margin=2.5cm}
\pagestyle{fancy}
\fancyhf{}
%------------------------

% ----- Custom Commands -----
\newcommand{\nt}[1]{\texttt{<#1>}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\B}{\mathbb{B}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\minilisp}{
  {M\footnotesize INI\normalsize L\footnotesize ISP \normalsize}
}
\renewcommand{\lstlistingname}{Código}
\renewcommand{\bibname}{Bibliografía}
%----------------------------

% ----- Book Document -----
% ----- Quitar mayúsculas automáticas -----
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{#1}}

% ----- Encabezados -----
\lhead{\minilisp}
\rhead{\leftmark{}.}
\cfoot{\thepage} % número centrado abajo
\renewcommand{\headrulewidth}{0.4pt}

% ----- Cambiar el título del índice -----
\addto\captionsspanish{%
  \renewcommand{\contentsname}{Índice} % cambia "Índice general" a "Índice"
}

% ----- Evitar mayúsculas en el encabezado del índice -----
\makeatletter
\renewcommand{\tableofcontents}{%
  \chapter*{\contentsname}% título "Índice"
  \markboth{\contentsname}{}% encabezado sin mayúsculas
  \@starttoc{toc}% genera el contenido real
}
\makeatother
%--------------------------

% ----- Custom Colors -----
\definecolor{azulin}{HTML}{130F87}
\definecolor{grisin}{HTML}{6D6C91}
\definecolor{links}{HTML}{0D1894}
\definecolor{mainkeywordcolor}{HTML}{610E61}
\definecolor{commentcolor}{HTML}{087008}
\definecolor{stringcolor}{HTML}{AD8318}
\definecolor{ops}{HTML}{3374A1}
\definecolor{tok}{HTML}{B39309}
\definecolor{tkns}{HTML}{560769}
\definecolor{asa}{HTML}{A81666}
\definecolor{corchets}{HTML}{A82E16}

\definecolor{secondkeywordcolor}{HTML}{0D1894}
\definecolor{thirdkeywordcolor}{HTML}{0D1894}

\definecolor{backgroundcolor}{rgb}{0.95, 0.95, 0.95}
%--------------------------

% ----- Haskell Code Style -----
\lstdefinestyle{haskellstyle}{
  language=Haskell,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=[1]\color{mainkeywordcolor}\bfseries,
  commentstyle=\color{commentcolor}\itshape,
  stringstyle=\color{stringcolor},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=8pt,
  backgroundcolor=\color{backgroundcolor},
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  captionpos=b,
  morekeywords=[1]{if,then,else,let,in,case,of,Show,Eq,
    data,type,class,instance,where, do,deriving,newtype,module,import}
}
%-------------------------------

% ----- JavaScript Code Style -----
\lstdefinelanguage{JavaScript}{
  keywords={break,case,catch,class,const,continue,debugger,default,
    delete,do,else,export,extends,false,finally,for,function,if,import,
    in,instanceof,new,null,return,super,switch,this,throw,true,try,
    typeof,var,void,while,with,yield,let,await,async},
  keywordstyle=\color{mainkeywordcolor}\bfseries,
  ndkeywords={Boolean,Number,String,Object,Array,Date,Math,JSON},
  ndkeywordstyle=\color{secondkeywordcolor},
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{commentcolor}\itshape,
  stringstyle=\color{stringcolor},
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{javascriptstyle}{
  language=JavaScript,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=[1]\color{mainkeywordcolor}\bfseries,
  keywordstyle=[2]\color{secondkeywordcolor},
  keywordstyle=[3]\color{thirdkeywordcolor},
  commentstyle=\color{commentcolor}\itshape,
  stringstyle=\color{stringcolor},
  numbers=left,
  numberstyle=\tiny\color{grisin},
  stepnumber=1,
  numbersep=8pt,
  backgroundcolor=\color{backgroundcolor},
  tabsize=2,
  showspaces=false,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  captionpos=b,
  morekeywords=[1]{function,return,if,else,for,while,do,break,continue,
    switch,case,default,try,catch,finally,throw,
    class,extends,constructor,super,this,new,delete},
  morekeywords=[2]{let,const,var,async,await,yield},
  morekeywords=[3]{true,false,null,undefined,NaN,Infinity},
  moredelim=[s][\color{ops}]{(}{)},
  moredelim=[s][\color{corchets}]{[}{]},
  moredelim=[s][\color{corchets}]{\{}{\}}
}
%-------------------------------

% ----- Bash Code Style -----
\lstdefinestyle{bashstyle}{
  language=bash,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=[1]\color{mainkeywordcolor}\bfseries,
  keywordstyle=[2]\color{secondkeywordcolor},
  commentstyle=\color{commentcolor}\itshape,
  stringstyle=\color{stringcolor},
  numbers=left,
  numberstyle=\tiny\color{grisin},
  stepnumber=1,
  numbersep=8pt,
  backgroundcolor=\color{backgroundcolor},
  tabsize=2,
  showspaces=false,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  captionpos=b,
  morekeywords=[1]{if,then,else,elif,fi,for,while,do,done,in,case,esac,
    function,return,exit,export,readonly,local},
  morekeywords=[2]{echo,cd,pwd,ls,cat,grep,sed,awk,find,chmod,chown,kill,ps},
  morecomment=[l]{\#},
  moredelim=[s][\color{tok}]{\$}{\ },
  moredelim=[s][\color{asa}]{\$\{}{\}}
}
%-------------------------------

% ----- Python Code Style -----
\lstdefinestyle{pythonstyle}{
  language=Python,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=[1]\color{mainkeywordcolor}\bfseries,
  keywordstyle=[2]\color{secondkeywordcolor},
  keywordstyle=[3]\color{thirdkeywordcolor},
  commentstyle=\color{commentcolor}\itshape,
  stringstyle=\color{stringcolor},
  numbers=left,
  numberstyle=\tiny\color{grisin},
  stepnumber=1,
  numbersep=8pt,
  backgroundcolor=\color{backgroundcolor},
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  captionpos=b,
  morekeywords=[1]{def,return,if,elif,else,for,while,break,continue,
    pass,import,from,as,class,try,except,finally,raise,with,yield,lambda},
  morekeywords=[2]{self,True,False,None},
  morekeywords=[3]{int,float,str,list,dict,set,tuple,len,range,print},
  moredelim=[s][\color{ops}]{(}{)},
  moredelim=[s][\color{corchets}]{[}{]},
  moredelim=[s][\color{corchets}]{\{}{\}}
}
%-------------------------------

\begin{document}

% ----- Importamos la portada -----
\input{portada}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ----- Ajustes para el pdf -----
\clearpage
\pagenumbering{arabic}
\setcounter{page}{1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ----- Iniciamos el indice -----
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introducción}
En el diseño de lenguajes de programación existe una distinción conceptual entre \textbf{alcance estático}
(también llamado \textbf{alcance léxico}\footnote{Utilizaremos ambos nombres indistintamente a lo largo del
reporte.}) y \textbf{alcance dinámico},el cual determina cómo se resuelven las referencias a variables y, por
ende, cómo se razona sobre el comportamiento de un programa.

\noindent
Aunque el \textit{alcance estático} se ha consolidado como el modelo dominante, diversos lenguajes de
programación (\textit{Lisp} en algunas de sus variantes, \textit{Python} en la organización de sus \texttt{namespaces} y \textit{JavaScript} en su manejo de cerraduras) incorporan \textbf{reglas mixtas} que combinan aspectos
de ambos modelos. Esto llega a presenta un desafío al razonar sobre el comportamiento del lenguaje y como
ejecuta los programas, especialmente en presencia de funciones anónimas, anidamiento o resolución diferida.\\

La importancia de este tema radica en que las reglas de alcance no son simplemente un detalle técnico, sino un
pilar fundamental en la semántica de los lenguajes. \textit{Michael. L. Scott} señala en su obra (\textit{Programming Lanfuahe Pragmatics}) \cite{ML-Scoot} que las decisiones sobre alcance influyen directamente en la claridad
del modelo mental que ofrece un lenguaje y en la facilidad con la que un programador puede predecir la evolución de un programa.

\noindent
Asimismo, desde la perspectiva de la expresividad, el tipo de alcance determina qué construcciones pueden
representarse de manera directa y cuáles requieren transformaciones adicionales, como argumenta
\textit{Matthias Felleisen} en su estudio sobre el poder expresivo de los lenguajes \cite{M-Felleisen}.
Por lo tanto, comprender por qué ciertos lenguajes adoptan reglas mixtas permite analizar de forma más crítica
sus capacidades, limitaciones y la clase de razonamiento que fomentan.\\

El objetivo de este trabajo es examinar las razones por las que lenguajes modernos emplean esquemas mixtos de
alcance y evaluar cómo estas elecciones influyen en la legibilidad y razonamiento del código, particularmente
en contexto de \textit{cadenas de ambientes, cerraduras y resolución diferida}. La metodología que llevamos a
cabo combina una revisión teórica de la literatura clásica sobre semántica de lenguajes con la implementación
práctica con la cual, veremos paso a paso como se desarrolla la evaluación de ambos alcances.
Con el fin de observar de manera concreta el comportamiento derivado de usar las reglas dependiendo del alcance empleado.

\noindent
Con esta doble aproximación permitimos relacionar los fundamentos conceptuales con las consecuencias prácticas para el desarrollo de software y la comprensión de programas.

%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Fundamentos teóricos}
El concepto de \textbf{alcance} es uno de los pilares de la semántica de los lenguajes de programación, pues
determina el contexto en el que una variable (o identificador) pueda ser utilizada y cómo se vincula con su
valor con el cuál es referenciado a lo largo del programa. Las distintas estrategias de alcance han sido
estudiadas y formalizadas extensamente en la literatura, dada su influencia directa en el razonamiento sobre
programas, la implementación de ambientes y la expresividad del lenguaje.

\section{Alcance léxico (estático)}
El \textit{alcance estático}, establece que la asociación entre un nombre y su valor se determina según la
estructura textual del programa. Es decir, para que se determine el valor de un identificador, este valor se
busca observando en el bloque de código o función donde fue declarado, independientemente desde donde fue
invocado. \textit{Michael Scott} formaliza este modelo como un sistema donde las regiones textuales del código
inducen un conjunto de ambientes anidados que el compilador puede determinar en tiempo de análisis \cite{ML-Scoot}.\\

En términos más simples, la formalización propuesta por Scott nos dice que: cada bloque de código del programa
define un \emph{ambiente} que contiene las variables declaradas en él, y que dichos ambientes se organizan de
forma jerárquica siguiendo la estructura del código fuente.

\noindent
Cuando un identificador es utilizado, el compilador (o en nuestro caso el intérprete) resuelve su referencia
buscando primero en el ambiente más interno y, si no lo encuentra, continúa la búsqueda en los ambientes externos
hasta localizar una definición válida.\\

Por ejemplo, en el siguiente fragmento de código:

\begin{verbatim}
x = 10
func f() {
    x = 20
    func g() {
        print(x)
    g()
    }
}
f()
\end{verbatim}

La variable \texttt{x} utilizada dentro de la función \texttt{g()} se asocia con la variable \texttt{x}
definida en \texttt{f}, ya que esa es la definición más cercana en la estructura textual del programa.

\noindent
Aunque \texttt{g()} es invocada desde \texttt{f()}, el valor de \texttt{x} que utiliza no depende del punto de
llamada, sino del entorno léxico en el que la función fue definida.\\

Las características principales del \textit{alcance estático} son:

\begin{itemize}
\item \textbf{Razonamiento local}: La visibilidad de las variables depende de la estructura del programa, un programador puede identificar cuales variables son visibles sin la necesidad de rastrear toda la ruta de ejecución.
  
\item \textbf{Soporte para cerraduras}: Una cerradura (o \textit{closure}\footnote{Del mismo modo que con el alcance léxico, nos referiremos a lo largo del reporte a estas como \textit{cerraduras} tanto como \textit{closures}.}) captura el ambiente léxico en el que fue definido. Justo como es mencionado en el trabajo de \textit{Daniel P. Friedman} (\textit{Essentials of Programming Languages} \cite{DP-Friedman}), nos referimos a este tipo de estructuras de datos como \textit{cerraduras} porque contienen todo lo que el proceso de evaluación necesita en el orden exacto que debe ser aplicado.

  Esto permite que las funciones sigan accediendo a variables externas aunque su bloque original haya terminado.
  
\item \textbf{Optimizaciones}: Como el compilador conoce la estructura de los ambientes de antemano, puede mejorar el rendimiento (usando el \textit{stack} eficientemente o eliminando variables inútiles) antes de correr el programa.
\end{itemize}

\section{Alcance dinámico}
El \textit{alcance dinámico} determina el valor de una variable basándose en la cadena de llamadas activa durante la ejecución. Lo que significa que un mismo nombre puede referirse a cosas distintas según quién llamó a la función, implicando que la asociación entre un nombre y su valor no depende de la estructura textual del código, sino del orden en que las funciones fueron invocadas. Generando como consecuencia, que un mismo identificador puede referirse a valores distintos según el contexto dinámico en el que se ejecuta.

\noindent
Nuevamente, \textit{Scott} señala que este modelo fue común en las primeras versiones de \textit{Lisp} debido a su simplicidad de implementación y a que facilitaba ciertas formas de extensibilidad \cite{ML-Scoot}. Ya que como se mencionó, las variables se resuelven recorriendo los ambientes generados por las llamadas a funciones que están activas en ese momento, comenzando por la más reciente y avanzando (o mejor dicho retrocediendo) hacia las anteriores.

\newpage

Por ejemplo, considérese el siguiente fragmento de código con \textit{alcance dinámico}:

\begin{verbatim}
x = 10
func f() {
    print(x)
}
func g() {
    x = 20
    f()
}
g()
\end{verbatim}

En este caso, cuando la función \texttt{f()} accede a la variable \texttt{x}, el valor utilizado es 20, ya que la
llamada a \texttt{f()} ocurre dentro del contexto de ejecución de \texttt{g()}, donde \texttt{x} fue definida.\\

Las características principales de este alcance son:

\begin{itemize}
\item \textbf{Dependencia de la ejecución}: El valor de una variable cambia según quién llame a la función. Esto da mucha flexibilidad, pero hace difícil predecir qué hará el programa sin ejecutarlo.
  
\item \textbf{Uso histórico y actual}: El \textit{alcance dinámico} fue ideal para los primeros lenguajes interpretados porque era muy fácil de implementar donde la simplicidad del intérprete tenía prioridad sobre la robustez del \textit{análisis estático}. Hoy en día se mantiene en contextos específicos (como sistemas de macros o configuraciones), donde es útil modificar el comportamiento global sin tener que pasar parámetros explícitamente a cada función.
\end{itemize}

\section{Modelos mixtos}
Ante las limitaciones de ambos enfoques, algunos lenguajes usan un enfoque \textit{\textbf{mixto}}, combinando estructuras léxicas claras bien definidas en tiempo de compilación, con mecanismos dinámicos que introducen flexibilidad en tiempo de ejecución. En estos sistemas, la estructura textual del programa sigue siendo fundamental para resolver la mayoría de las referencias, pero ciertos identificadores o comportamientos se determinan dinámicamente según el estado de ejecución.

\noindent
\textit{Martín Abadi} y \textit{Luca Cardelli} argumentan que la frontera entre lo estático y lo dinámico no es
absoluta. En su trabajo sobre tipado dinámico en lenguajes estáticamente tipados () señalan que incluso sistemas
diseñados con fuertes garantías estáticas pueden incorporar características dinámicas (como la carga tardía),
obligando la información disponible en tiempo de compilación con decisiones que solo pueden tomarse en tiempo de
ejecución \cite{M-Abadi}.\\

Un ejemplo representativo es \textbf{Python}, que utiliza \textit{alcance léxico} para las variables locales y
cerraduras, pero mantiene reglas dinámicaspara la resolución de los global y lo predefinido. En particular,
cuando una variable no se encuentra en el ambiente local ni en los ambientes léxicos externos, el intérprete
recurre dinámicamente a ambientes globales y \texttt{built-in}. Este comportamiento ilustra cómo un lenguaje con una base léxica clara incorpora decisiones dinámicas en la resolución final de dichas variables \cite{Python-Software}.\\

De manera similar, \textbf{JavaScript} sigue un patrón parecido al mezclar \textit{closures} con un ambiente
global dinámico y mutable. Si bien las funciones capturan el ambiente en el que fueron definidas, la existencia
de un objeto global compartido y mecanismos como \texttt{this} (cuyo enlace depende del contexto de invocación)
introducen elementos propios del \textit{alcance dinámico}. Así, la referencia a ciertos identificadores no puede
determinarse únicamente a partir de la estructura textual del programa \cite{JS-Closures}.\\

En el caso de \textbf{Lisp}, el carácter mixto es aún más explícito. Aunque las versiones modernas utilizan
principalmente \textit{alcance estático}, muchos dialectos permiten declarar \textit{variables especiales} con
\textit{alcance dinámico}. Estas variables se resuelven siguiendo la cadena de llamadas activa, coexistiendo con variables léxicas ordinarias dentro del mismo programa \cite{Lisp-DScope}.

\section{Conceptos clave}

\subsection{Cerraduras}
Son funciones que capturan su ambiente léxico en el momento de su definición. \textit{Friedman} y \textit{Wand} como mencionamos anteriormente, describen las \textit{closures} como pares que combinan código y ambiente, permitiendo diferir la ejecución sin perder contexto, justo porque contienen todo lo que la evaluación necesita en el orden exacto en el cual se debe realizar la aplicación \cite{DP-Friedman}.

\subsection{Ambientes}
Son estructuras que modelan la asociación entre identificadores y sus valores durante la ejecución de un
programa. Formalmente, pueden entenderse como funciones o estructuras de mapeo que, dado un nombre, permiten recuperar el valor o ubicación correspondiente.

\noindent
La implementación eficiente de ambientes, especialmente en presencia de funciones recursivas y llamadas en cola, ha sido estudiada por \textit{William D. Clinger}, quien los analiza, desde una perspectiva operacional, destacando su papel en la correcta implementación de la \emph{recursión adecuada} (\textit{Proper Tail Recursion}) \cite{WD-Clinger}. \textit{Clinger} demuestra que, bajo un manejo apropiado de los ambientes, las llamadas en posición de cola no requieren la creación de nuevos marcos de ambiente, lo que permite que la ejecución de funciones recursivas en cola se realice utilizando espacio constante.\\

Podemos decir entonces, que desde este punto de vista, los ambientes no deben interpretarse únicamente como estructuras de acumulación, sino como esctructuras que pueden ser reutilizadas, compartidas o descartadas según la semántica del lenguaje y la posición de las llamadas.

\subsection{Cadenas de alcance}
Son secuencias ordenadas de ambientes que representan los posibles contextos donde se puede resolver una
variable. Cada elemento de la cadena corresponde a un ambiente asociado a un bloque o función. En los lenguajes
con \textit{alcance estático}, esta cadena se determina estáticamente (valga la redundancia), mientras que en lenguajes con alcance dinámico, la cadena se construye en tiempo de ejecución siguiendo la pila de llamadas activa

\subsection{Contextos de ejecución}
Son \textit{marcos de activación} creados al invocar funciones o bloques de código, que almacenan variables
locales, parámetros y referencias a ambientes externos. Además de que estos contienen la información necesaria
para reanudar la ejecución, como la dirección de retorno y el estado de evaluación.

%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Análisis de lenguajes modernos}
Cada lenguaje mezcla los alcances según sus propios objetivos. En la historia de \textit{Lisp} y \textit{Scheme}, esto se ve claramente en la diferencia entre \textbf{let} (que crea un ambiente léxico fijo) y \textbf{let-dynamic} (que sigue el flujo de ejecución).

\noindent
\textit{Common Lisp} estandarizó esto con las llamadas "\textit{variables especiales}", que actúan de forma dinámica dentro de un sistema que es mayormente léxico \cite{GL-Steele}. Según \textit{Gregor Kiczales}, estas variables son muy fuertes ya que permiten cambiar el comportamiento global sin tener que pasar parámetros extra, lo cual es la base de sistemas avanzados como los meta-objetos \cite{G-Kiczales}.\\

\textit{Python} organiza su alcance con la regla \textbf{LEGB}: \textit{Local, Enclosing, Global} y \textit{Built-in}. Este esquema es fundamentalmente léxico, pero incorpora mecanismos que permiten ajustar la resolución de nombres desde funciones anidadas: \textbf{nonlocal} permite modificar variables en un ambiente externo no global, mientras que \textbf{global} habilita cambios sobre nombres del módulo, introduciendo así flexibilidad dinámica en la manipulación de ámbitos \cite{Python-Software}. Estas reglas proporcionan un equilibrio entre claridad léxica y flexibilidad, siempre y cuando se preste atención al modificar variables dentro de funciones anidadas.\\

Por su parte, \textit{JavaScript} combina \textit{cerraduras} léxicas con un sistema de contextos de ejecución bien definidos. La introducción de \textbf{let} y \textbf{const} sustituyó gradualmente a \texttt{var} para evitar la confusión que causaba su \textit{hoisting} (elevación de variables) pues, esto podía generar ambigüedades semánticas \cite{ECMA}.

\noindent
Además, el uso histórico de la sentencia \texttt{with} que intentaba alterar dinámicamente el ambiente de las variables, pero solo lograba hacer el código ilegible. Tal como señala \textit{Gilda Bracha}, estas variaciones reflejan una transición desde modelos más dinámicos hacia diseños con mayor predicibilidad y claridad estructural \cite{G-Bracha}.\\

Pese a sus diferencias sintácticas, estos lenguajes comparten patrones comunes. Todos parten de una base léxica pero incluyen excepciones dinámicas (como el manejo de estructuras de contexto global o algunas palabras clave) que introducen elementos dinámicos. El resultado, crea modelos híbridos donde la claridad del \textit{alcance léxico} coexiste con la necesidad de operar de manera flexible en tiempo de ejecución.

%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ventajas de desventajas de los modelos mixtos}
Como hemos visto, los modelos de alcance mixtos combinan estructuras léxicas con mecanismos dinámicos, una mezcla
que ofrece beneficios notables en lenguajes orientados a la extensibilidad y a la programación funcional.

\begin{itemize}
\item \textbf{Flexibilidad}: Permiten introducir parámetros implícitos, ajustar comportamientos globales o representar configuraciones contextuales sin modificar explícitamente todas las funciones involucradas. Esto es útil en sistemas que requieren manejar el contexto de ejecución sin romper la estructura modular del programa.
  
\item \textbf{Compatibilidad}: Facilitan la evolución del lenguaje, permitiendo que características antiguas (como variables especiales o comportamientos heredados) convivan con mecanismos léxicos modernos.
  
\item \textbf{Control}: En el ámbito funcional, la coexistencia de cerraduras con ambientes dinámicos ofrece un control muy preciso del estado. Como señalan Abelson y Sussman, esto es clave para mantener la modularidad en diseños complejos \cite{H-Abelson}.
\end{itemize}

Sin embargo, estos beneficios vienen acompañados de desventajas:
\begin{itemize}
\item \textbf{Complejidad}: El programador debe pensar en dos lógicas a la vez (estática y dinámica), lo que dificulta entender el código.
  
\item \textbf{Pérdida de seguridad}: \textit{Dave Clarke} y \textit{Sophia Drossopoulou} advierten que, al permitir que un nombre se resuelva en tantos lugares, se rompe el encapsulamiento y se debilita el sistema \cite{D-Clarke}.
  
\item \textbf{Depuración difícil}: Es complicado rastrear errores cuando el valor de una variable depende de una cadena de llamadas compleja.
  
\item \textbf{Mantenimiento}: Según \textit{Erdweg}, en proyectos grandes esto reduce la predictibilidad y hace difícil actualizar el software, especialmente si se usa metaprogramación \cite{S-Erdweg}.
  
\item \textbf{Rendimiento}: El sistema se vuelve más lento porque debe gestionar estructuras para ambos tipos de alcance.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementación práctica}
El propósito de esta implementación es ilustrar (de manera más concreta) cómo se presentan las reglas de alcance léxico y dinámico.

Para ello, en nuestro programa reutilizaremos la base de nuesto proyecto 1 \minilisp. Pero agregando las evaluaciones de ambos alcances para ver los diferentes resultados de aplicarlos. A su vez que mostramos paso por paso lo que internamente se va procesando: como las cerraduras que se crean con los ambientes que se caputaran o las asignaciones que se van agregando al ambiente.\\

Dado que reutilizamos gran parte del programa implementado en \minilisp, la explicación de gran parte del código es breve y directa.

\section{Arquitectura del programa}
Cada módulo transforma los datos de entrada de la siguiente manera:

Damos el siguiente ejemplo de entrada:

\begin{quote}
  "\texttt{(let (x 10) (+ x 5))}"
\end{quote}

\begin{itemize}
\item \textbf{Lexer (Alex)}: En este parte de la implementación su función es la de convertir el texto plano en tokens.
  
  \begin{lstlisting}[style=haskellstyle, caption={Estructura del lexer con Alex}]
    tokens :-
    $white+                       ;  -- Ignorar espacios
    \(                            { \_ -> TokenPA }
    \)                            { \_ -> TokenPC }
    "lambda"                      { \_ -> TokenLambda }
    "-"?$digit+                   { \s -> TokenNum (read s) }
    $alpha($alnum)*               { \s -> TokenVar s }
  \end{lstlisting}

  Para nuestro ejemplo:
  
  \begin{quote}
    \texttt{[TokenPA, TokenLet, TokenPA, TokenVar "x", TokenNum 10, TokenPC, TokenPA, TokenSum...]}
  \end{quote}
  
\item \textbf{Parser (Happy)}: El parser se encarga de transformar los tokens en árbol sintáctico usando la herramienta \textbf{Happy}.

  \begin{lstlisting}[style=haskellstyle, caption={Gramática para lets del parser (Happy)}]
    ASA : '(' "let" '(' var ASA ')' ASA ')'    { Let $4 $5 $7 }
    | '(' "lambda" '(' vars ')' ASA ')'        { Lambda (reverse $4) $6 }
    | '(' ASA appArgs ')'                      { App $2 (reverse $3) }
  \end{lstlisting}
  
  Estructura de salida (ASA.hs):
  
  \begin{lstlisting}[style=haskellstyle, caption={Estructura del árbol de sintaxis abstracta (ASA.hs)}]
    data ASA = Var String
    | Num Int
    | Let String ASA ASA
    | Lambda [String] ASA
    | App ASA [ASA]
    | Add [ASA]
    deriving (Show, Eq)
  \end{lstlisting}

  Para nuestro ejemplo, al pasarle la lista de tokens:
  
  \begin{quote}
    \texttt{Let} "\texttt{x}" \texttt{(Num 10) (Add [Var} "\texttt{x}"\texttt{, Num 5])}
  \end{quote}
    
\item \textbf{Desugar}: La responsabilidad es de convertir el ASA "azucarado" a su forma núcleo. Para este caso, a diferencia de la implementaición de \minilisp, desazucaramos los tipos de dato ASA a tipos de dato ASV.\\
  
  Transformaciones (Desugar.hs):
  
  \begin{lstlisting}[style=haskellstyle, caption={Transformaciones del desazucarador (Desugar.hs)}]
    --Let aplicacion de funciones
    desugar (Let i v b) = AppV (FunV i (desugar b)) (desugar v)
    --Lambda multi-parametro y se 'currifica'
    desugar (Lambda ps b) = desugarLmb ps b 
    --Operadores n-arios a binarios
    desugar (Add xs) = desugarOps AddV xs
  \end{lstlisting}

  Definimos las estructuras de ambientes que usaremos junto con las formas núcleo como sigue:

  \begin{lstlisting}[style=haskellstyle, caption={Estructura del núcleo (ASV.hs)}]
    type Env = [(String, ASV)]
    
    data ASV = VarV String
    | NumV Int
    | BoolV Bool
    | FunV String ASV
    | AppV ASV ASV
    | Closure String ASV Env
    deriving (Show, Eq)
  \end{lstlisting}

  En nuestro pequeño ejemplo queda como sigue:

  \begin{quote}
    \texttt{AppV (FunV} "\texttt{x}" \texttt{(AddV (VarV} "\texttt{x}"\texttt{) (NumV 5))) (NumV 10)}
  \end{quote}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Para nuestro intérprete, tenemos los módulos \texttt{StaticScope} y \texttt{DynamicScope} para realizar la evaluacion con alcance estático y dinámico respectivamente. La principal diferencia entre ellos es el como evalúan las funciones lambda (\texttt{FunV}) y las aplicaciones de funciones (\texttt{AppV}).

\subsection{Intérprete Estático}
Como sabemos, al utilizar el alcance estatico necesitamos implementar el concepto de cerraduras para caputar el ambiente y preservar el valor de una variable en el momento en el cual fue invocada.
Nuestra funcion pasitoLex (pasito porque utilizamos evaluación de paso pequeño y Lex por LexicalScope, el término en inglés para alcance estático) hace lo justo cuando cae en el patrón \texttt{FunV}:

\begin{lstlisting}[style=haskellstyle, caption={Evaluación de \texttt{FunV} con alcance estático.}]
  pasitoLex :: ASV -> Env -> (ASV, Env)
  --Buscamos la variable en el ambiente
  pasitoLex (VarV i) env = (lookupEnv i env, env)
  --Creamos las cerraduras a partir de funciones
  pasitoLex (FunV p c) env =
  let msg = "[Closure]: lamb" ++ p ++ ". captura el ambiente: { " 
            ++ showEnv env ++ " }"
  in trace msg (Closure p c env, env)
\end{lstlisting}

Al caer en un \texttt{FunV}, simplemente creamos la cerradura capturando el ambiente actual:

\[
  \texttt{(Closure p c env, env)}
\]

Está parte es una de las mas importantes ya que es el proceso necesario para convertir el alnace dinámico en estático, lo que hace es añadir un tercer campo al constructor que guarda al ambiente actual. \\

A su vez que nos apoyamos de la función \texttt{trace} de Haskell para indicarle al usuario que hemos creado la cerradura con el ambiente actual. Además \texttt{trace} nos apoyamos de la función \texttt{trace}{showEnv} para mostrar en texto el ambiente que capturamos con la cerradura:

\begin{lstlisting}[style=haskellstyle, caption={Función para mostrar al usuario el ambiente actual.}]
  -- Funcion auxiliar para representar ambientes
  showEnv :: Env -> String
  showEnv [] = ""
  showEnv ((x,v):xs) = x ++ " -> " ++ saca v ++ (if null xs then "" else ", " ++ showEnv xs)
\end{lstlisting}

Hacemos un breve parentesis para explicar que hemos extendido el propósito de la función \texttt{saca}, implementada con anterioridad para mostrar al usuario los valores canónicos resultantes de la evaluación al programa dado como una representación comprensible para el mismo. Sin embargo como hemos implementado la función de mostrar nuestro proceso de evaluación con alcances, necesitábamos extender esta función; ya que no podemos asegurar que el ambiente tenga puramente valores finales.

\begin{lstlisting}[style=haskellstyle, caption={Resumen de la función saca extendida para mostrar los ASV al usuario.}]
  saca :: ASV -> String
  saca (NumV n)  = show n
  saca (BoolV True)  = "#t"
  saca (BoolV False) = "#f"
  saca (VarV x) = x
  saca (AppV f a) = "(" ++ saca f ++ " " ++ saca a ++ ")"
  saca (FunV p body) = "lamb" ++ p ++ ". " ++ saca body
  saca (Closure p body env) = "<lamb" ++ p ++ ". " ++ saca body ++ ", env = {" ++ showEnv env ++ "}>"
\end{lstlisting}

Continuando con las reglas de pasitoLex, tenemos ahora la regla para la aplicación de funciones. Recordemos que, tenemos dos casos para evaluar en paso pequeño la aplicación de funciones. En la primer regla no hay mucho que explicar que no hayamos ya comentado en el primer proyecto:

\begin{lstlisting}[style=haskellstyle, caption={Evaluaciónn de \texttt{AppV} con alcance estático.}]
  pasitoLex (AppV (Closure p c e) a) env
    | isValue a || isClosure a =
        let msg = "[Aplicacion]: Asignando " ++ p ++ " = " ++ saca a
                  ++ " en el ambiente capturado"
        in trace msg (c, (p, a) : e)
    | otherwise =
      let (a', env') = pasitoLex a env
      in (AppV (Closure p c e) a', env')
  pasitoLex (AppV f a) env = let (f', env') = pasitoLex f env
                             in (AppV f' a, env')                       
\end{lstlisting}

Simplemente evaluamos continuamos con la aplicación de la función f aplciada al arguemnto a, pero evaluando esta función a su vez que extendemos el ambiente.

Para el siguiente caso, en donde ya tenemos una cerradura la cuál aplicar, comprobamos que sea un valor canónico. De ser este el caso, realizamos la aplicación del cuerpo con el valor a en base al parámetro que se tiene bajo el ambiente de la cerradura, no de la aplicación de función. Aclaramos además, que también mostramos la sustitución que se hace al parámetro al momento de la aplicación. En otro caso, seguimos evaluando el argumento a hasta llegar a un valor.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Intérprete Dinámico}
Continuamos ahora con nuestra implementación para la evaluación con alcance dinámico.

Para el alcance dinámico en nuestro programa, implementamos la función \texttt{pasitoDyn}, el cuál se diferencia de \texttt{pasitoLex} en las evaluaciones a funciones y aplicaciones de funciones. Al evaluar \texttt{FunV} no hacemos gran cosa, simplemente regresamos la misma función, pues como hemos mencionado, con el alcance dinámico no generamos cerraduras; resolvemos las variables en base al ambiente en el momento de la ejecución.

Para la aplicación de funciones, evaluamos la función a aplicar hasta llegar al tipo \texttt{FunV}. En este caso, una vez el argumento es un valor realizamos la sustitución del parámetro $p$ con ese valor y lo asignamos al ambiente.

\begin{lstlisting}[style=haskellstyle, caption={Evaluación de \texttt{AppV} con alcance dinámico.}]
  pasitoDyn :: ASV -> Env -> (ASV, Env)
  pasitoDyn (AppV (FunV p c) a) env
    | isValue a || isFunV a =
        trace ("[Aplicacion]: Asignando " ++ p ++ " = " ++ saca a ++ " en el ambiente") (c, (p, a) : env)
    | otherwise =
      let (a', env') = pasitoDyn a env
      in (AppV (FunV p c) a', env')
  pasitoDyn (AppV f a) env = let (f', env') = pasitoDyn f env
                             in (AppV f' a, env')
\end{lstlisting}

Como extra, agregamos la característica de mostrar al usuario cuando \texttt{lookupEnv} tiene éxito y encuentra una variable $i$ en el ambiente, mostramos esa variable con el valor asignado. Lo podemos ver a continuación:

\begin{lstlisting}[style=haskellstyle, caption={Evaluación de \texttt{AppV} con alcance dinámico.}]
  lookupEnv :: String -> Env -> ASV
  lookupEnv i [] = error ("Variable 'Var " ++ i ++ "' no definida")
  lookupEnv i ((j, v):e)
    | i == j =
        trace ("[Lookup]: " ++ j ++ " -> " ++ saca v) v
    | otherwise = lookupEnv i e
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Interfaz principal}
Para probar el programa, agregados una validación de prefijos para que el usuario vea los resultados de evaluar expresiones con alguno de los dos alcances o con ambos:

\begin{lstlisting}[style=haskellstyle, caption={Función \texttt{validate} para validar la entrada del usuario.}]
  validate :: String -> IO ()
  validate input
    | "staticScope" `isPrefixOf` input = let expr = quitPrefix "staticScope" input
                                         in evalMode True False expr
    | "dynamicScope" `isPrefixOf` input = let expr = quitPrefix "dynamicScope" input
                                          in evalMode False True expr
    | "compareScopes" `isPrefixOf` input = let expr = quitPrefix "compareScopes" input
                                           in evalMode True True expr
    | otherwise = do
        putStrLn "Por favor indique el tipo de alcance:"
        putStrLn "staticScope <expr>"
        putStrLn "dynamicScope <expr>"
        putStrLn "compareScopes <expr>"
\end{lstlisting}

Nos apoyamos del operador \texttt{`isPrefixOf`} para comprobar que el usuario haya solicitado un alcance con el cual evaluar la expresión. En caso de éxito llamamos a la otra función \texttt{evalMode} para comenzar a evaluar la expresión dada por el usuario quitando el prefijo del alcance que solicitado.

\begin{lstlisting}[style=haskellstyle, caption={Funciones auxiliares \texttt{evalMode} y \texttt{quitPrefix} para procesar la entrada del usuario.}]
  -- Evaluamos la expresion usando alcance estatico/dinamico Bool1 para static Bool2 para dynamic
  evalMode :: Bool -> Bool -> String -> IO ()
  evalMode static dynamic expr = do
    let tokens = lexer expr
    let asa    = parse tokens
    let asv   = desugar asa
    if static
      then do
      let res = evalStatic asv []
      putStrLn "\n===== Alcance Estatico ====="
      putStrLn (saca res)
      else return ()
    if dynamic
      then do
      let res = evalDynamic asv []
      putStrLn "\n===== Alcance Dinamico ====="
      putStrLn (saca res)
      else return ()
    putStrLn ""

  -- Eliminamos el prefijo (staticScope/dynamicScope/bothScope) y espacios extra
  quitPrefix :: String -> String -> String
  quitPrefix pref str = dropWhile (== ' ') (drop (length pref) str)
\end{lstlisting}

Con \texttt{evalMode} evaluamos la expresión dada a través de toda nuestra arquitectura de \minilisp, desde el analizador léxico, hasta sacar el valor resultante. Antes de ello dependiendo del alcance solicitado se evaluará esa expresión con nuestros intérpretes.\\

En resumen, para probar el programa, se deben escribir los comandos de la siguiente manera:

\begin{lstlisting}[style=haskellstyle, caption={}]
  #Para ver los resultados con alcance estatico unicamente:
  [MiniLisp]> staticScope <expr>
  ...
  #Para solo ver los resultados con alcance dinamico:
  [MiniLisp]> dynamicScope <expr>
  ...
  #Para ver ambos resultados y comparar:
  [MiniLisp]> compareScopes <expr>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Casos de Estudio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Closures en Alcance Léxico en JavaScript}
Como sabemos, una \textit{cerradura} (o \textit{closure}) es una función que retiene el acceso a variables fuera de la función, incluso después de que dicha función haya terminado su ejecución. Este mecanismo permite que la función "\textit{recuerde}" las asginaciones echas dentro de esta. Lo que denominamos \textit{ambiente}, con el alcance estático hacemos que se guarda el ambiente en el cual fue creada, manteniendo acceso a variables que de otra manera estarían fuera de alcance.

\noindent
Veamos por ejemplo una implementacion en Javascript \cite{JS-Closures}:

\begin{lstlisting}[style=javascriptstyle, caption={Función ejemplo para mostrar el funcionamiento de cerraduras en JavaScript.}]
   function foo() {
       let var = "Holaaa!";
       function hoo() {
           console.log(var); 
           var = "Adios..."
       }
       return hoo;  
   }
   const closure = foo(); 
   closure();
   closure();
\end{lstlisting}

La salida es:

\begin{verbatim}
  Holaaa!
  Adios..
\end{verbatim}

En este ejemplo:\\

\noindent
En la primer llamada \texttt{closure();}, \texttt{foo()} se ejecuta creando un nuevo ambiente para este.

En ese ambiente se mete: \texttt{[var ->} "\texttt{Holaa!}"\texttt{]}. Como JavaScript implementa alcance estáticos, cuando \textit{hoo} es definida, captura el ambiente donde fue creada, incluyendo \texttt{var} pues ya estaba en el ambiente, obviamente. Este ambiente creado es de la forma: \texttt{closure = \{ [var ->} "\texttt{Holaaa!}"\texttt{] \}}.

Cuando \texttt{foo()} termina y devuelve la función \texttt{hoo()}, aunque la pila de ejecución de \texttt{foo()} también se borra, su ambiente no lo hace, porque \texttt{hoo()} lo sigue guardando por su cerradura. Por ello decimos que una cerradura “\textit{recuerda}” su ambiente donde fue declarada.

De este modo en la primer llamada, usamos la cerradura y se imprime "\textit{Holaaa!}", y después de imprimir se modifica el ambiente capturado con \texttt{[var ->} "\texttt{Adiós...}"\texttt{]}. Así es como se imprime en la segunda llamada "\textit{Adios...}" pues ahora \texttt{var} ya fue modificado en el ambiente guardado dentro de la cerradura.

Si lo pensamos bien, las cerraduras estan fuertemente ligadas al tema de varibales locales y globales, pues con estas logramos que una función mantenga variables ocultas y que solo sean accesibles dentro de esa función.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Alcance Dinámico con Bash}
En contraste, tenemos el alcance dinámico resuelve las variables basándose en el contexto de ejecución actual, no en el ámbito de definición. Bash ser caracteriza por ser uno de los pocos lenguajes modernos que aún preserva el uso del alcance dinámico\footnote{Como bien se explica en su documentación, citando: "Las variables en la terminal (Shell) implementan el alcance estático para controlar la visibilidad de una variable dentro de las funciones."} \cite{GNU-Bash}.\\

Veamos el siguiente ejemplo \cite{Lex-Dyn}:

\begin{lstlisting}[style=bashstyle, caption={Ejemplo en Bash para mostrar el alcance dinámico.}]
  #!/bin/bash
  
  var="es global"
  
  function foo() {
    echo "var: $var"
  }
  
  function hoo() {
    local var="es local"
    foo
  }
  
  hoo
\end{lstlisting}

La salida es:

\begin{verbatim}
  var: es local
\end{verbatim}

En este ejemplo:\\
\texttt{foo()} busca \texttt{var} en su donde fue declarada (en \texttt{hoo()}), no donde se definió. Antes de que se llame a \texttt{hoo()} el ambiente tiene: \texttt{[ var -> }"\textit{es global}" \texttt{]}, al llamarse a \texttt{hoo()}, metemos al ambiente \texttt{[ var ->} "\textit{es local}" ], por lo que este es nuestra variable \texttt{var} más reciente. De este modo, al evaluarse \texttt{foo()}, \texttt{var} es la cadena "es local" ya que es la que se encuentra primero. Por ello se imprime "\textit{var: es local}".\\

El ambiente de la función es simplemente la cadena de activaciones en tiempo de ejecución, como una pila. Por lo que no hay un ambiente estático que conservar, por ello no hay closures. Y es esta la principal diferencia entre alcance dinámico y estático.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Closures en Python}

En esta sección analizamos el caso particular de Python, un lenguaje que implementa
\emph{alcance léxico} de forma similar a JavaScript, pero con procesos más
explícitos que reflejan un diseño mixto controlado. Python prioriza la
claridad semántica y la prevención de errores. Como se mencionó en el capítulo anterior, esto surge a partir de uno de los axiomas fundamentales del lenguaje \cite{TZP}.

A diferencia de JavaScript, donde una función puede modificar variables de ambientes
exteriores sin una declaración previa, Python exige el uso explícito de las palabras
clave \texttt{nonlocal} o \texttt{global} para alterar variables fuera del ambiente local.
Esto se hace evidente cuándo una función interactúa con su ambiente externo,
reduciendo ambigüedades en el razonamiento del código.

\begin{lstlisting}[style=pythonstyle, caption={Ejemplo de closure en Python.}]
def funcion_externa():
    mensaje = "Hola"
    
    def funcion_interna():
        nonlocal mensaje  # Declaracion explicita 
        print(mensaje)
        mensaje = "Adios"
    
    return funcion_interna

closure = funcion_externa()
closure()  # Imprime: "Hola"
closure()  # Imprime: "Adios"
\end{lstlisting}

En el ejemplo anterior, \texttt{funcion\_interna} constituye un \emph{closure}, ya que
captura la variable \texttt{mensaje} definida en su ambiente envolvente. El uso de
\texttt{nonlocal} indica explícitamente que la asignación debe afectar a dicha variable y
no crear una nueva en el ambiente local de la función interna.

Como se explicó previamente, Python utiliza un proceso de búsqueda de identificadores
conocido como la regla \textbf{LEGB}, que define el orden en el que se resuelven los
nombres:

\begin{itemize}
    \item \textbf{Local}: variables definidas en la función actual.
    \item \textbf{Enclosing}: variables definidas en funciones envolventes.
    \item \textbf{Global}: variables definidas a nivel de módulo.
    \item \textbf{Built-in}: identificadores incorporados por el lenguaje.
\end{itemize}

\begin{lstlisting}[style=pythonstyle, caption={Proceso \texttt{nonlocal} y regla LEGB.}]
x = "global"

def nivel1():
    x = "enclosing"
    
    def nivel2():
        nonlocal x  # Accede a x de nivel1, no a la global
        x = "modificado"
        return x
    
    return nivel2

func = nivel1()
print(func())  # "modificado"
print(x)       # "global"
\end{lstlisting}

Este comportamiento puede representarse en nuestro lenguaje de la siguiente manera:

\begin{lstlisting}[style=haskellstyle, caption={Simulación del comportamiento de Python en MiniLisp.}]
-- Simulacion aproximada del comportamiento de Python
(let (x "global")
     (let (nivel1 (lambda ()
                    (let (x "enclosing")
                         (let (nivel2 (lambda ()
                                        -- En Python seria necesario "nonlocal"
                                        (let (x "modificado")
                                             x)))
                              (nivel2)))))
          (nivel1)))
\end{lstlisting}

Actualmente, nuestro lenguaje no distingue ambientes local, enclosing ó global; sin embargo, podría extenderse para soportar este modelo.

Python representa un punto de equilibrio en el diseño del manejo de alcance:
no es tan permisivo como JavaScript, pero tampoco tan restrictivo como otros lenguajes. Su modelo respeta el alcance léxico, mantiene consistencia
conceptual y fomenta buenas prácticas al hacer explícitas las interacciones entre ambientes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Comparando resultados con nuestro programa}
Para contrastar ambos comportamientos en nuestro intérprete, utilizamos los ejemplos:

\begin{lstlisting}[style=javascriptstyle, caption={Ejemplo evaluación con alcance estático en JavaScript.}]
  let x = 21;
  function foo() {
    console.log(x);
  }
  function goo() {
    let x = 73;
    foo();
  }
  goo(); // La salida es 21
\end{lstlisting}

\begin{lstlisting}[style=bashstyle, caption={Ejemplo evaluación con alcance dinámico en Bash.}]
  y = 21
  foo() {
    echo $y;
  }
  goo() {
    local y = 73;
    foo;
  }
  bar  #Se imprime 73 esta vez
\end{lstlisting}

Los ejemplos anteriores los podemos modelar en nuestro programa como sigue:

\begin{verbatim}
(let (x 21)
     (let (foo (lambda (u) x))
          (let (hoo (lambda (v) (let (x 73) (foo 0))))
               (hoo 0))))
\end{verbatim}

Elegimos parámetros distintos ($u$ y $v$) en las definiciones de las funciones $\lambda$, para evitar colisiones de nombres con la variable libre $x$. Además hacemos las aplicaciones \texttt{(foo 0)} y \texttt{(hoo 0)} porque necesitamos forzar una aplicación de función por que: en el alcance estático, se usa el ambiente guardado en la cerradura y en el alcance dinámico, se busca en el ambiente de llamada.

Notemos además, que por el mismo motivo, el valor del argumento en la aplicación no importa, por ello ponemos 0 por omisión.\\

Al dar esta expresión por nuestro intérprete podemos ver que la salida corresponde a cada evaluación:

\begin{lstlisting}[style=haskellstyle, caption={}]
[MiniLisp]> staticScope (let (x 21) (let (foo (lambda (u) x)) (let (hoo (lambda (v) (let (x 73) (foo 0)))) (hoo 0))))

===== Alcance Estatico =====
[Closure]: lx. captura el ambiente: {  }
[Aplicacion]: Asignando x = 21 en el ambiente capturado
[Closure]: lfoo. captura el ambiente: { x -> 21 }
[Closure]: lu. captura el ambiente: { x -> 21 }
[Aplicacion]: Asignando foo = <lu. x, env = {x -> 21}> en el ambiente capturado
[Closure]: lhoo. captura el ambiente: { foo -> <lu. x, env = {x -> 21}>, x -> 21 }
[Closure]: lv. captura el ambiente: { foo -> <lu. x, env = {x -> 21}>, x -> 21 }
[Aplicacion]: Asignando hoo = <lv. (lx. (foo 0) 73), env = {foo -> <lu. x, env = {x -> 21}>, x -> 21}> en el ambiente capturado
[Lookup]: hoo -> <lv. (lx. (foo 0) 73), env = {foo -> <lu. x, env = {x -> 21}>, x -> 21}>
[Aplicacion]: Asignando v = 0 en el ambiente capturado
[Closure]: lx. captura el ambiente: { v -> 0, foo -> <lu. x, env = {x -> 21}>, x -> 21 }
[Aplicacion]: Asignando x = 73 en el ambiente capturado
[Lookup]: foo -> <lu. x, env = {x -> 21}>
[Aplicacion]: Asignando u = 0 en el ambiente capturado
[Lookup]: x -> 21
21
\end{lstlisting}

En nuestro resultado con alcance estático:

\begin{enumerate}[label=\arabic*.]
\item Se define $x$ en un ambiente vacío, luego lo asginamos como $x = 21$ en el ambiente.
\item Se define foo como \texttt{(lambda (u) x)}, con \texttt{[Closure]: $\lambda$u.} captura el ambiente: \texttt{\{ x -> 21 \}}, \texttt{foo} hace lo propio de \texttt{foo}, capturar la versión de $x$ que había en ese momento, es decir: $x = 21$.
  
  Esta es la esencia del alcance estático, la función recuerda el ambiente del momento de su definición.
  
\item Luego definimos \texttt{hoo}, que internamente hace un let \texttt{(x 73)} antes de llamar a \texttt{foo}.
\item Finalmente hacemos \texttt{(hoo 0)}. Dentro de \texttt{hoo}, aparece una nueva $x = 73$, pero como la variable libre $x$ de \texttt{foo} ya estaba capturada con \texttt{x -> 21}, la nueva $x$ no afecta a la que usa \texttt{foo}.

  Por ello aparece: \texttt{[Lookup]: x -> 21}, y ese es el resultado final: 21. Coincidiendo correctamente con el ejemplo propuesto en JavaScript.
\end{enumerate}

Al intentarlo con alcance dinámico:

\begin{lstlisting}[style=haskellstyle, caption={}]
[MiniLisp]> dynamicScope (let (x 21) (let (foo (lambda (u) x)) (let (hoo (lambda (v) (let (x 73) (foo 0)))) (hoo 0))))

===== Alcance Dinamico =====
[Aplicacion]: Asignando x = 21 en el ambiente
[Aplicacion]: Asignando foo = lu. x en el ambiente
[Aplicacion]: Asignando hoo = lv. (lx. (foo 0) 73) en el ambiente
[Lookup]: hoo -> lv. (lx. (foo 0) 73)
[Aplicacion]: Asignando v = 0 en el ambiente
[Aplicacion]: Asignando x = 73 en el ambiente
[Lookup]: foo -> lu. x
[Aplicacion]: Asignando u = 0 en el ambiente
[Lookup]: x -> 73
73
\end{lstlisting}

\begin{enumerate}[label=\arabic*.]
\item Al definir \texttt{foo} en modo dinámico, no se captura ambiente, a diferencia del caso estático, sino que podemos ver que se imprime:
  
  \[
  \texttt{[Aplicación]: Asignando foo = $\lambda$u. x en el ambiente}
  \]
  
  Pero nunca aparece la creación de una closure con ambiente capturado.
  
\item Después, dentro de hoo, redefinimos $x = 73$.
\item Cuando \texttt{foo} es llamada, ahora la búsqueda de la variable $x$ ocurre en el ambiente de la llamada, no en el ambiente de definición. Lo podemos ver claramente en: \texttt{[Lookup]: x -> 73}
  
  Por lo tanto el resultado es 73.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusiones}
La implementación de nuestro proyecto es un mini-lenguaje con alcance configurable, muestra que la elección entre alcance léxico y dinámico es una decisión central en el diseño de lenguajes de programación. El alcance léxico facilita el razonamiento sobre el código, favorece el encapsulamiento y contribuye a la creación de programas más claros y mantenibles. En contraste, el alcance dinámico ofrece mayor flexibilidad al permitir que ciertos valores dependan del contexto de ejecución, lo cual resulta útil en escenarios de configuración y parámetros implícitos.

Lenguajes modernos como JavaScript y Python utilizan principalmente alcance léxico, pero lo aplican con enfoques distintos. JavaScript permite modificaciones implícitas del ambiente, lo que incrementa la flexibilidad, mientras que Python exige el uso explícito de \texttt{nonlocal} y \texttt{global}, priorizando la claridad y la prevención de errores. Estas diferencias evidencian que no existe un modelo único ideal, sino que cada lenguaje equilibra expresividad, seguridad y facilidad de uso según sus objetivos.

La implementación en Haskell permitió observar que, aunque la diferencia entre ambos modelos puede expresarse con cambios mínimos en el evaluador, sus efectos semánticos son significativos. Finalmente, el proyecto confirma que es posible diseñar lenguajes que soporten múltiples reglas de alcance, brindando a los programadores la flexibilidad de elegir el modelo más adecuado, y destaca la importancia de una arquitectura modular como buena práctica en el diseño de lenguajes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{chapter}{Bibliografía}
\begin{thebibliography}{99}

\bibitem{ML-Scoot}
  M. L. Scott, Programming Language Pragmatics, 2nd ed. San Francisco, CA: Morgan Kaufmann, 2006.

\bibitem{M-Felleisen}
  M. Felleisen, “On the expressive power of programming languages,” Science of Computer Programming, vol. 17,1991.

\bibitem{DP-Friedman}
  D. P. Friedman and M. Wand, Essentials of Programming Languages, 3rd ed. Cambridge, MA: MIT Press, 2008.

\bibitem{M-Abadi}
  M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin, “Dynamic typing in a statically typed language,” ACM Transactions on Programming Languages and Systems, vol. 13, 1991.

\bibitem{Python-Software}
  Python Software Foundation, “Python Documentation,” 2023.

\bibitem{JS-Closures} MAFER <formato IEEE>
  https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Closures

\bibitem{Lisp-DScope} MAFER <formato IEEE>
  https://www.deinprogramm.de/sperber/papers/dynamic-scope-analysis.pdf
  

  
\bibitem{WD-Clinger}
  W. D. Clinger, “Proper tail recursion and space efficiency,” PLDI '98: Proceedings of the ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation, 1998.

\bibitem{GL-Steele}
  G. L. Steele, Common Lisp the Language, 2nd ed. Mountain View, CA: Digital Press, 1990.

\bibitem{G-Kiczales}
  G. Kiczales et al., The Art of the Metaobject Protocol. Cambridge, MA: MIT Press, 1991.

\bibitem{ECMA}
  ECMA International, ECMAScript® 2023 Language Specification, ECMA-262, 2023.
    
\bibitem{G-Bracha}
  G. Bracha, “Blocks in Java,” OOPSLA Workshop on Closures, 2004.

\bibitem{D-Clarke}
  D. Clarke and S. Drossopoulou, “Ownership, encapsulation, and the disjointness of type and effect,” OOPSLA, 2002.

\bibitem{S-Erdweg}
  S. Erdweg et al., “Sound and predictable software evolution,” Onward!, 2015.

\bibitem{H-Abelson}
  H. Abelson and G. J. Sussman, Structure and Interpretation of Computer Programs, 2nd ed., MIT Press, 1996.
  
\bibitem{GNU-Bash} MAFER <formato IEEE>
  foooo https://www.gnu.org/software/bash/manual/bash.html

\bibitem{TZP}
T. Peters,\textit{The Zen of Python},PEP~20, Python Software Foundation, 2004.

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
%-------------------------------
